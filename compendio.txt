COMPENDIO PROGETTO: Ticketing NFT MVP

(Stato Aggiornato: Sabato 19 Aprile 2025, ~12:21 CEST - Altamura, Italia)

1. Informazioni Generali e Obiettivi

Nome Progetto: Ticketing NFT MVP
Obiettivo Primario MVP: Realizzare una piattaforma demo funzionante per la vendita primaria (minting) e secondaria (marketplace P2P) di biglietti NFT per eventi. La piattaforma deve implementare meccanismi anti-scalping basilari (price cap nel marketplace) e offrire un'esperienza utente (UX) semplice e intuitiva.
Target Primario: Demo Funzionante / Ricerca Finanziamenti Iniziali (Seed).
Sviluppatore Principale: Lorenzo (Altamura/Bari).
Contesto Attuale: Questo compendio serve come punto di riferimento aggiornato per continuare lo sviluppo in modo efficiente, consolidando le informazioni dalle sessioni precedenti.
2. Repository GitHub e Riferimento Changelog

Repository: Il codice sorgente completo del progetto è disponibile su GitHub:
https://github.com/modernage12/ticketing-nft/tree/main
Changelog Dettagliato: Per una cronologia dettagliata delle modifiche, implementazioni e decisioni prese durante lo sviluppo, fare riferimento al file changelog.txt presente nel repository (o fornito separatamente).   
3. Stack Tecnologico e Setup Ambiente

Architettura: Monorepo gestito con npm workspaces.
packages/contracts: Smart Contracts Solidity.
packages/backend: API Server Node.js/Express.
packages/frontend: Applicazione Web Vue.js.
Ambiente Sviluppo Locale:
OS: Windows 10/11.
Node.js: v22.14.0 (o versione LTS compatibile).
Package Manager: npm.
Database Locale: PostgreSQL (versione recente).
Smart Contracts (packages/contracts):
Linguaggio: Solidity (versione >=0.8.0).
Framework: Hardhat (v2.23.0).
Librerie: OpenZeppelin Contracts v5.3.0 (installate manualmente, non via npm nel monorepo principale per semplicità iniziale).
Testnet: Polygon Amoy.
RPC Provider (per Deploy/Interazioni dirette): Infura (endpoint Amoy configurato in .env del backend).
Indirizzi Deployati (Amoy - Esempio):
TicketNFT.sol: 0x1Ce... (Verificare l'indirizzo attuale se necessario).
Marketplace.sol: 0xAec... (Verificare l'indirizzo attuale se necessario).
Backend (packages/backend):
Framework: Node.js / Express.
Database: PostgreSQL con client pg.
Interazione Blockchain: Ethers.js v6.
Autenticazione: jsonwebtoken (JWT), bcrypt (hashing password).
Middleware: cors, express.json.
Configurazione: dotenv (per variabili d'ambiente come DATABASE_URL, JWT_SECRET, INFURA_AMOY_URL, PRIVATE_KEY del minter).
Gestione Chiavi Utente: Custodial Ibrido. Le chiavi private degli utenti che non usano un wallet esterno sono generate dal backend, criptate con AES-GCM (usando una chiave derivata dalla password utente o una chiave dedicata) e salvate nella tabella Users. Gli utenti possono opzionalmente collegare un wallet esterno (MetaMask).
Frontend (packages/frontend):
Framework: Vue.js 3 (Composition API preferita).
Build Tool: Vite.
Routing: Vue Router.
State Management: Pinia (authStore, walletStore, eventStore, etc.).
Chiamate API: Axios (istanza configurata axios-config.js).
Interazione Blockchain: Ethers.js v6 (principalmente per utilità di formattazione come formatEther e per interazione con wallet esterno via window.ethereum).
4. Architettura Generale (Monorepo, Flusso Dati)

Monorepo: Permette di gestire codice interdipendente (contratti usati dal backend, tipi condivisi potenzialmente) in un unico repository. L'installazione delle dipendenze e l'esecuzione degli script avviene dalla root del progetto.
Flusso Utente Base (Wallet Interno):
Utente si registra/logga (Frontend -> Backend API Auth). Il backend genera/recupera la chiave privata criptata.
Utente visualizza eventi (Frontend -> Backend API Eventi -> DB).
Utente acquista biglietto (Frontend -> Backend API Eventi/Tickets).
Il Backend verifica disponibilità (DB).
Il Backend usa la chiave privata del minter (da .env) per chiamare mintTicket sullo Smart Contract TicketNFT, passando l'indirizzo del wallet dell'utente (recuperato/decriptato dal DB).
Il Backend aggiorna DB (Tickets, Events).
Utente visualizza "I Miei Biglietti" (Frontend -> Backend API Tickets -> DB Tickets + letture on-chain occasionali per status listing).
Utente mette in vendita biglietto (Frontend -> Backend API Marketplace).
Backend verifica proprietà (DB/on-chain).
Backend usa chiave utente (decriptata) per chiamare approve su TicketNFT (per Marketplace) e listTicket su Marketplace.
Backend aggiorna DB (Listings).
Altro utente visualizza Marketplace (Frontend -> Backend API Marketplace -> DB Listings).
Altro utente acquista biglietto P2P (Frontend -> Backend API Marketplace).
Backend verifica listing, prezzo (vs price cap).
Backend usa chiave acquirente (decriptata) per chiamare buyTicket su Marketplace.
Backend aggiorna DB (Listings, Tickets).
Flusso Wallet Esterno: L'utente collega MetaMask. Il frontend gestisce la connessione e ottiene l'indirizzo. Per azioni che richiedono firma (List/Buy/Cancel nel marketplace), il frontend dovrebbe costruire la transazione e chiedere la firma via MetaMask, inviando poi la transazione firmata o l'hash al backend per monitoraggio/aggiornamento DB (questa parte è meno sviluppata rispetto al flusso custodial). L'acquisto primario potrebbe ancora avvenire via backend (minting sull'indirizzo esterno dell'utente), ma la vendita/acquisto P2P richiederebbe interazione diretta o firme EIP-712 gestite dal backend. L'MVP attuale si concentra sul flusso custodial/ibrido semplice.
Cache DB Manuale: Per migliorare le performance percepite e ridurre le chiamate RPC (specialmente su Infura gratuito), le letture principali (eventi, biglietti posseduti, listing marketplace) avvengono primariamente dal database PostgreSQL del backend. Le tabelle vengono aggiornate dal backend dopo il successo delle transazioni on-chain (minting, listing, buy, cancel). Questo introduce un potenziale ritardo o discrepanza tra stato on-chain e stato mostrato, accettato come compromesso per l'MVP.
5. Smart Contracts (Dettagli)

TicketNFT.sol (packages/contracts/contracts/TicketNFT.sol)
Standard: ERC721 (probabilmente ERC721Enumerable per tracciare i token di un utente).
Ownership: Ownable (probabilmente con owner inizialmente impostato all'indirizzo del deployer/admin).
Minting: Funzione mintTicket(toAddress, eventId, originalPrice) chiamata solo da un indirizzo autorizzato (es. Minter/Backend Wallet, gestito via modifier onlyOwner o ruolo specifico).
Metadati: Mappa ticketData(tokenId => TicketInfo) dove TicketInfo è una struct contenente eventId, originalPrice, ecc.
ID Token: Contatore auto-incrementante.
Marketplace.sol (packages/contracts/contracts/Marketplace.sol)
Logica Core:
listTicket(tokenId, price): Richiede approve precedente su TicketNFT. Registra il listing (struct Listing mappata tokenId => Listing). Emette evento TicketListed.
buyTicket(tokenId): Richiede msg.value >= listing.price. Trasferisce MATIC al venditore, trasferisce NFT (safeTransferFrom) all'acquirente. Gestisce il price cap (require(listing.price <= ticketData[tokenId].originalPrice)). Rimuove listing. Emette evento TicketSold.
cancelListing(tokenId): Chiamabile solo dal venditore (listing.seller). Rimuove listing. Emette evento ListingCancelled.
Price Cap: Implementato nel buyTicket (o listTicket) per prevenire vendita a prezzo superiore all'originale.
Eventi: Fondamentali per il monitoraggio off-chain (anche se non usati attivamente dalla cache DB manuale attuale).
6. Backend (Dettagli API, DB, Servizi)

API Endpoints Principali (packages/backend/src/routes/)
/api/auth: /register, /login. Gestisce creazione utente (con wallet interno), login (restituisce JWT e preferenza wallet), potenziale recupero wallet.
/api/events:
GET /: Recupera tutti gli eventi (da DB).
POST /: Crea un nuovo evento (solo Admin). Richiede adminAuthMiddleware.
POST /:eventId/buy: Acquista (minta) un biglietto per l'evento specificato (richiede auth utente).
/api/tickets:
GET /my-tickets: Recupera i biglietti posseduti dall'utente loggato (da DB Tickets). Può includere check on-chain (lento/fallibile) per status isListed.
/api/marketplace:
GET /listings: Recupera i biglietti attualmente in vendita (da DB Listings).
POST /list: Mette in vendita un biglietto posseduto. Richiede auth utente, tokenId, price.
POST /buy: Acquista un biglietto listato. Richiede auth utente, listingId (o tokenId).
POST /cancel: Annulla un listing. Richiede auth utente, listingId (o tokenId).
/api/users (o in auth): Endpoint per aggiornare preferenza wallet (/update-preference).
Database Schema (PostgreSQL - Principali Tabelle)
users: user_id (PK, es. SERIAL o UUID), username (UNIQUE), password_hash, encrypted_private_key (TEXT/BYTEA, NULLable), wallet_address (indirizzo derivato da chiave privata), is_admin (BOOLEAN DEFAULT false), wallet_preference (TEXT DEFAULT 'internal', può essere 'external'), external_wallet_address (TEXT NULL UNIQUE, per SIWE futuro o riferimento).
events: event_id (PK, SERIAL), name, description (TEXT), date (TIMESTAMP WITH TIME ZONE), location, original_price (NUMERIC), total_tickets (INTEGER), tickets_minted (INTEGER DEFAULT 0), image_url (TEXT NULL), created_at.
tickets: ticket_id (PK, SERIAL), token_id (VARCHAR/NUMERIC, UNIQUE?), nft_contract_address, owner_wallet_address, owner_user_id (FK a users), event_id (FK a events), original_price (NUMERIC), issuance_date (TIMESTAMP), is_listed (BOOLEAN DEFAULT false), last_checked_block (INTEGER, per caching stato on-chain).
listings: listing_id (PK, SERIAL), ticket_id (FK a tickets, UNIQUE?), token_id (VARCHAR/NUMERIC), seller_wallet_address, seller_user_id (FK a users), price (NUMERIC), listed_at (TIMESTAMP), is_active (BOOLEAN DEFAULT true).
Servizi Principali (packages/backend/src/services/)
authService: Logica per registrazione, login, gestione JWT, crittografia chiavi.
eventService: Logica per creare eventi, recuperare eventi, mintare biglietti (interazione contratto TicketNFT, aggiornamento DB Events e Tickets).
ticketService: Logica per recuperare biglietti utente.
marketplaceService: Logica per listare, comprare, cancellare listing (interazione contratto Marketplace, aggiornamento DB Listings, Tickets).
Middleware Chiave (packages/backend/src/middleware/)
authMiddleware: Verifica token JWT per rotte protette standard. Allega req.user (con userId, walletAddress).
adminAuthMiddleware: Verifica token JWT E flag is_admin nel DB per rotte admin. Allega req.user (con userId, username, isAdmin).
7. Frontend (Dettagli UI, Store, Interazioni)

Componenti Principali (packages/frontend/src/views/ e src/components/)
App.vue: Struttura principale, Navbar, gestione stato wallet globale (connessione/disconnessione).
LoginView.vue, RegisterView.vue: Form per autenticazione.
EventsView.vue: Mostra lista eventi (da store/API). Include pulsante "Compra Biglietto". Formatta prezzo da Wei a MATIC.
MyTicketsView.vue: Mostra biglietti posseduti dall'utente (da store/API). Include pulsante "Vendi" (che apre modale/prompt per prezzo).
MarketplaceView.vue: Mostra biglietti in vendita (da store/API). Include pulsante "Compra".
CreateEventView.vue: Form per creazione evento (accessibile da Admin).
SettingsView.vue: Permette all'utente di switchare tra wallet interno ed esterno.
Componenti riutilizzabili (es. EventCard.vue, TicketCard.vue, ListingCard.vue).
State Management (Pinia - packages/frontend/src/stores/)
authStore: Gestisce stato autenticazione (token, dati utente, isAuthenticated, isAdmin), azioni login, register, logout, WorkspaceUserData.
walletStore: Gestisce stato connessione wallet esterno (MetaMask), indirizzo connesso, signer, stato isUsingExternalWallet, azioni connectWallet, disconnectWallet, ensureSigner. Interagisce con authStore per persistere la preferenza.
eventStore (o simile): Gestisce stato lista eventi, azione WorkspaceEvents.
ticketStore (o simile): Gestisce stato biglietti utente, azione WorkspaceMyTickets.
marketplaceStore (o simile): Gestisce stato listings, azioni WorkspaceListings, listTicket, buyListing, cancelListing.
Routing (packages/frontend/src/router/index.js)
Definisce le rotte (/login, /register, /events, /my-tickets, /marketplace, /create-event, /settings).
Implementa navigation guards (beforeEach) per proteggere rotte che richiedono autenticazione (meta: { requiresAuth: true }) o privilegi admin (meta: { requiresAdmin: true }).
8. Modifiche Chiave al Database (Locale -> Da Replicare Online)

Le seguenti modifiche sono state apportate allo schema del database PostgreSQL locale durante lo sviluppo e dovranno essere replicate su qualsiasi istanza di database di staging o produzione:

Tabella users:
Aggiunta colonna wallet_preference TEXT DEFAULT 'internal' NOT NULL; (per tracciare scelta wallet interno/esterno).
Aggiunta colonna is_admin BOOLEAN DEFAULT false NOT NULL; (per ruolo admin).
(Nota: Era stata aggiunta external_wallet_address e resa password_hash NULLable per SIWE, ma poi revertita. Assicurarsi che lo schema finale sia quello desiderato).
Tabella events:
Aggiunta colonna image_url TEXT NULL; (per URL immagine evento).
Modificato tipo colonna original_price da BIGINT a NUMERIC; (per supportare valori Wei).
Aggiunta colonna tickets_minted INTEGER DEFAULT 0 NOT NULL; (per tracciare biglietti mintati vs total_tickets).
Comandi SQL Esempio (da adattare se necessario):

SQL

-- Per Tabella Users
ALTER TABLE users ADD COLUMN wallet_preference TEXT DEFAULT 'internal' NOT NULL;
ALTER TABLE users ADD COLUMN is_admin BOOLEAN DEFAULT false NOT NULL;

-- Per Tabella Events
ALTER TABLE events ADD COLUMN image_url TEXT NULL;
ALTER TABLE events ALTER COLUMN original_price TYPE NUMERIC;
ALTER TABLE events ADD COLUMN tickets_minted INTEGER DEFAULT 0 NOT NULL;
9. Stato Funzionale Attuale (Al 19 Aprile 2025)

Core Funzionalità MVP:
Registrazione e Login (Username/Password con wallet interno generato).
Collegamento/Scollegamento Wallet Esterno (MetaMask) e persistenza preferenza.
Visualizzazione Eventi (con prezzo formattato).
Acquisto Primario Biglietti (Minting via backend, funziona per wallet interno).
Visualizzazione Biglietti Posseduti.
Messa in Vendita Biglietti (Marketplace P2P - flusso base con wallet interno).
Acquisto Secondario Biglietti (Marketplace P2P - flusso base con wallet interno, include price cap).
Annullamento Listing.
Creazione Eventi (Solo Admin, tramite UI dedicata).
Problemi Noti / Polish UI:
UI Bottone "Compra" nel Marketplace non si disabilita visivamente per le proprie offerte (ma la logica blocca l'acquisto). (Priorità Bassa).
UI Input Prezzo "Vendi" in "I Miei Biglietti" usa ancora window.prompt. (Priorità Media).
Stile Generale: Funzionale ma esteticamente molto basilare, richiede CSS Polishing.
Compromessi Accettati:
Lettura dati primariamente da Cache DB manuale (potenziale lieve ritardo rispetto a on-chain).
Gestione limiti RPC Infura (letture intensive possono rallentare/fallire, frontend gestisce mostrando dati vecchi dove possibile).
10. Roadmap Immediata (Post-Creazione Eventi)

Priorità definite per arrivare alla Demo MVP:

(Opzionale/In Corso) CSS Polishing Minimo: Migliorare l'aspetto visivo generale per renderlo più presentabile.
Deployment: Pubblicare Frontend (Vercel/Netlify) e Backend+DB (Render) su piattaforme gratuite. Questo è cruciale per la demo.
Seed Data / Reset: Implementare uno script o un endpoint API (protetto da admin) per popolare/resettare il database con dati di test per facilitare le demo.
Documentazione / Preparazione Demo: Preparare documentazione utente minima e/o una scaletta per guidare una demo efficace del flusso principale.
11. Idee Future (Post-MVP Demo)

Migliorare integrazione Wallet Esterno (gestire firme EIP-712 per listing/buy senza custodia backend).
Abilitare creazione eventi/NFT direttamente da UI per organizzatori autorizzati (non solo admin globali).
Integrazione Pagamenti FIAT (es. Stripe per acquisto primario, convertendo in crypto per minting).
Cache DB Robusta (usare event listener da smart contract via WebSocket/TheGraph o polling più intelligente per aggiornamenti quasi real-time).
Miglioramenti UX (notifiche, feedback visivo, gestione errori).
Test più approfonditi (Unit, Integration, E2E).
12. Istruzioni per Continuare lo Sviluppo

Punto di Partenza: Il codice nel repository GitHub linkato è aggiornato e include la funzionalità di creazione eventi funzionante.
Focus: Concentrarsi sulla Roadmap Immediata (Polishing, Deployment, Seed/Reset, Docs) per raggiungere l'obiettivo della Demo MVP.
Evitare Regressioni: Non reintrodurre problemi già risolti relativi a:
Funzionalità core (Auth, Mint, List, Buy, Cancel sono OK nel flusso base).
Limiti RPC (la cache DB manuale è la soluzione attuale).
Errori specifici di database o codice già corretti (fare riferimento al changelog.txt o a questo compendio).
Database: Ricordarsi di applicare le modifiche DB (Sezione 8) a qualsiasi nuovo ambiente DB.
Comunicazione: Mantenere il changelog.txt aggiornato con le modifiche significative.

XX. Idee Future Dettagliate (Post-MVP Demo)

Flusso Pagamento Acquisto Primario (Minting):

Obiettivo: L'utente acquirente paga effettivamente il prezzo del biglietto + commissioni al momento del minting.
Logica Proposta:
L'utente paga PrezzoBiglietto + CommissioneServizio (+ Gas Fee implicita).
PrezzoBiglietto viene trasferito al wallet dell'Organizzatore/Creatore dell'evento (indirizzo associato all'evento).
CommissioneServizio viene trasferita a un wallet designato per il servizio.
L'NFT del biglietto viene mintato e trasferito all'acquirente.
Implicazioni: Richiede modifiche significative allo smart contract TicketNFT (o a un contratto di vendita primaria dedicato) per gestire msg.value, trasferire fondi a creatore e servizio. Necessario associare un indirizzo di pagamento a ogni evento nel DB e potenzialmente nello smart contract. Modifiche a backend e frontend per gestire il pagamento.
Flusso Pagamento Marketplace P2P:

Obiettivo: L'utente acquirente paga effettivamente il prezzo del biglietto listato + commissioni al venditore e al servizio.
Logica Proposta:
L'acquirente paga PrezzoListing + CommissioneServizio (+ Gas Fee implicita).
PrezzoListing viene trasferito al wallet del Venditore.
CommissioneServizio viene trasferita al wallet del servizio.
L'NFT viene trasferito dal Marketplace (o dal venditore previa approve) all'acquirente.
Implicazioni: Richiede modifiche significative allo smart contract Marketplace per gestire msg.value e la distribuzione dei fondi tra venditore e servizio. Modifiche a backend e frontend.
Utilizzo Wallet Selezionato (Interno/Esterno):

Obiettivo: Le azioni on-chain (List, Buy, Cancel nel marketplace, potenzialmente altre future) devono essere eseguite usando l'identità (e quindi firmando la transazione) del wallet che l'utente ha attualmente selezionato (interno gestito dal backend o esterno via MetaMask).
Stato Attuale: Il sistema ibrido esiste (l'utente può scegliere), ma le azioni on-chain vengono probabilmente ancora gestite sempre tramite il backend che usa la chiave interna (o la chiave del minter per il minting primario).
Implicazioni: Modifiche importanti necessarie sia nel backend (per verificare la preferenza utente prima di agire) sia soprattutto nel frontend. Se l'utente usa un wallet esterno, il frontend deve:
Preparare i dati della transazione (chiamata a funzione del contratto, parametri, valore ETH/MATIC).
Richiedere all'utente di firmare e inviare la transazione tramite il provider del wallet esterno (es. MetaMask).
Gestire la risposta (hash della transazione) e comunicarla al backend per aggiornare lo stato off-chain (DB cache).
Ruolo Utente "Organizzatore/Creatore di Eventi":

Obiettivo: Permettere a utenti specifici (diversi dagli admin globali) di creare e gestire i propri eventi tramite l'interfaccia utente.
Logica Proposta:
Introdurre un nuovo ruolo/flag nel DB per gli utenti (es. is_creator BOOLEAN).
Modificare il middleware di autorizzazione per la rotta POST /api/events (e future rotte di gestione eventi) per permettere l'accesso agli utenti con is_admin = true OPPURE is_creator = true.
Associare gli eventi creati all'ID dell'utente creatore nel DB.
(Opzionale) Creare un'interfaccia (accessibile solo agli admin) per assegnare/revocare il ruolo is_creator agli utenti.
Implicazioni: Principalmente modifiche al backend (DB schema, middleware, controller eventi) e potenzialmente una piccola aggiunta UI per la gestione dei ruoli.
Quale affrontare per prima?

Analizzando la complessità:

Ruolo Utente "Organizzatore" (Idea 4): Sembra la più semplice da implementare in questa fase. Riguarda principalmente logica backend standard (DB, middleware) e non richiede modifiche agli smart contract o ai flussi di firma complessi nel frontend.
Utilizzo Wallet Selezionato (Idea 3): Ha una complessità media, richiede un lavoro significativo sul frontend per gestire l'invio di transazioni tramite wallet esterni.
Flussi di Pagamento (Idea 1 e 2): Sono le più complesse perché richiedono modifiche sostanziali agli smart contract (che sono più difficili da aggiornare una volta deployati) oltre a modifiche coordinate a backend e frontend.


Modifiche al Database Locale (da Replicare per Deployment Online)

Questa sezione riassume tutte le modifiche strutturali che abbiamo apportato allo schema del database PostgreSQL locale durante lo sviluppo recente. Queste modifiche devono essere applicate a qualsiasi database utilizzato per il deployment (staging o produzione) affinché l'applicazione funzioni correttamente.

Tabella users:

Aggiunta colonna: is_admin BOOLEAN DEFAULT false NOT NULL
Aggiunta colonna: is_creator BOOLEAN DEFAULT false NOT NULL
Aggiunta colonna: wallet_preference TEXT DEFAULT 'internal' NOT NULL
(Ricontrollare se altre modifiche come external_wallet_address sono state mantenute o revertite secondo le decisioni finali)
Tabella events:

Aggiunta colonna: tickets_minted INTEGER DEFAULT 0 NOT NULL
Aggiunta colonna: image_url TEXT NULL
Modifica tipo colonna: ALTER COLUMN original_price TYPE NUMERIC (da BIGINT o qualsiasi fosse prima a NUMERIC)
Comandi SQL Esempio (da eseguire sul DB di destinazione):

SQL

-- Modifiche Tabella Users
ALTER TABLE users ADD COLUMN is_admin BOOLEAN DEFAULT false NOT NULL;
ALTER TABLE users ADD COLUMN is_creator BOOLEAN DEFAULT false NOT NULL;
ALTER TABLE users ADD COLUMN wallet_preference TEXT DEFAULT 'internal' NOT NULL;
-- Aggiungere qui eventuali altre ALTER TABLE per users se necessarie

-- Modifiche Tabella Events
ALTER TABLE events ADD COLUMN tickets_minted INTEGER DEFAULT 0 NOT NULL;
ALTER TABLE events ADD COLUMN image_url TEXT NULL;
ALTER TABLE events ALTER COLUMN original_price TYPE NUMERIC;

XX. Aggiornamento Stato Sviluppo (19 Aprile 2025)

Completamento Funzionalità Precedenti: Implementati e testati Ruolo "Event Creator" e Registrazione come Creator, risolvendo bug relativi ad autorizzazione, stato frontend, DB e UI.
Cambiamento di Priorità (Post-MVP Base): È stato deciso di anticipare l'implementazione dei flussi di pagamento on-chain con commissioni (Idee 1 e 2) rispetto al polishing/deployment dell'MVP attuale.
Razionale: Stabilire la corretta logica di pagamento e trasferimento fondi negli smart contract è visto come un prerequisito fondamentale per poter poi integrare efficacemente l'utilizzo dei wallet esterni selezionati dall'utente (Idea 3) per tutte le azioni transazionali (acquisto primario e P2P).
Fase Attuale - Inizio Implementazione Flussi di Pagamento Reali:
Obiettivo: Modificare gli smart contract e l'applicazione full-stack per gestire transazioni economiche reali (in MATIC/cryptovaluta della testnet/mainnet) sia per l'acquisto primario che per quello secondario, includendo una commissione per il servizio.
Scope Principale:
Smart Contract (TicketNFT.sol, Marketplace.sol): Progettare, implementare e testare modifiche per:
Rendere le funzioni di acquisto (mintTicket pubblica o nuova funzione, buyTicket P2P) payable.
Gestire msg.value per verificare il pagamento corretto (prezzo + commissione).
Distribuire i fondi: inviare il prezzo al creatore/venditore e la commissione a un wallet designato per il servizio.
Definire e gestire l'indirizzo del wallet del servizio e la percentuale/importo della commissione (probabilmente configurabili dall'owner del contratto).
Associare un indirizzo di pagamento al creatore dell'evento (potrebbe richiedere modifiche al minting o dati off-chain).
Backend: Adattare i servizi e i controller per interagire con le nuove funzioni degli smart contract, gestire/recuperare gli indirizzi di pagamento dei creatori, potenzialmente esporre informazioni sulle commissioni.
Frontend: Aggiornare l'UI per mostrare i prezzi (eventualmente con dettaglio commissioni), modificare la logica di acquisto per interagire con le nuove API/contratti.
Prossimo Passo Immediato: Discussione e progettazione dettagliata delle modifiche necessarie agli Smart Contract TicketNFT.sol e Marketplace.sol.

XX. Aggiornamento Stato Sviluppo (19 Aprile 2025)

Completamento Funzionalità Precedenti: Implementati e testati Ruolo "Event Creator" e Registrazione come Creator, risolvendo bug relativi ad autorizzazione, stato frontend, DB e UI.
Cambiamento di Priorità (Post-MVP Base): È stato deciso di anticipare l'implementazione dei flussi di pagamento on-chain con commissioni fisse per la piattaforma (Idee 1 e 2) rispetto al polishing/deployment dell'MVP attuale.
Razionale: Stabilire la corretta logica di pagamento e trasferimento fondi negli smart contract per entrambi i flussi (acquisto primario e P2P) è visto come un prerequisito fondamentale per poter poi integrare efficacemente l'utilizzo dei wallet esterni selezionati dall'utente (Idea 3) e per creare un modello di business sostenibile per la piattaforma.
Fase Attuale - Inizio Implementazione Flussi di Pagamento Reali:
Obiettivo: Modificare gli smart contract e l'applicazione full-stack per gestire transazioni economiche reali (in MATIC/cryptovaluta) sia per l'acquisto primario che per quello secondario, includendo una commissione percentuale fissa (definita dalla piattaforma) per il servizio.
Scope Principale:
Smart Contract (TicketNFT.sol, Marketplace.sol, potenziale nuovo Sale Contract): Progettare, implementare e testare modifiche per:
Definire stato on-chain (configurabile solo dall'owner) per: indirizzo del wallet di servizio e percentuale di commissione.
Rendere payable le funzioni di acquisto (minting primario, acquisto P2P).
Gestire msg.value per verificare il pagamento corretto (prezzo + commissione).
Distribuire i fondi:
Acquisto Primario: Prezzo all'indirizzo del creatore dell'evento (richiede meccanismo per associare/recuperare indirizzo creatore), Commissione al wallet di servizio.
Acquisto P2P: Prezzo Listing al venditore, Commissione al wallet di servizio.
Gestire il trasferimento dell'NFT all'acquirente.
Backend: Adattare servizi/controller per interagire con i nuovi contratti, gestire/recuperare gli indirizzi di pagamento dei creatori, esporre dati su prezzi/commissioni.
Frontend: Aggiornare UI (dettaglio prezzi/commissioni), modificare logica d'acquisto.
[2025-04-19 ~14:50 CEST] - Sviluppo Smart Contract: Revisionato codice `Marketplace.sol` fornito con implementazione iniziale commissioni P2P (basis points, wallet servizio, funzioni setter, eventi, logica in `buyItem`).
[2025-04-19 ~14:55 CEST] - Bugfix Smart Contract: Corretto uso di `.transfer()` in `Marketplace.sol` (funzione `buyItem`) rimuovendo assegnazione risultato booleano e `require` successivi, in linea con Solidity >=0.8.0.
[2025-04-19 14:45 CEST] - Sviluppo Smart Contract: Deciso di mantenere modificabili (solo da owner) la commissione (`serviceFeeBasisPoints`) e il wallet di servizio (`serviceWallet`) in `Marketplace.sol` per flessibilità futura. Codice attuale con funzioni `set...` e modificatore `onlyOwner` confermato.
Fase Attuale - Implementazione Flussi di Pagamento Reali & Test:
Obiettivo: Modificare gli smart contract e l'applicazione full-stack per gestire transazioni economiche reali (in MATIC/cryptovaluta) sia per l'acquisto primario che per quello secondario, includendo una commissione percentuale fissa (definita dalla piattaforma) per il servizio.
Scope Principale:
Smart Contract (TicketNFT.sol, Marketplace.sol): [...] (invariato)
Test Smart Contract: Completati test unitari/integrazione approfonditi per `Marketplace.sol` utilizzando Hardhat, coprendo listing, acquisto con commissioni, cancellazione e funzioni amministrative. Risolto problema ambientale legato all'esecuzione dei test. (NUOVO)
Backend: [...] (invariato)
Frontend: [...] (invariato)
Prossimo Passo Immediato: Implementare la logica delle commissioni nel contratto di minting primario (`TicketNFT.sol` o contratto dedicato) e scrivere i relativi test. Successivamente, adattare backend e frontend.
13. Note di Debug Ambiente Test
Durante lo sviluppo dei test Hardhat per Marketplace.sol (19/04/2025), è stato riscontrato un problema persistente nell'ambiente di esecuzione `npx hardhat test`. Un errore "incorrect number of arguments to constructor" impediva il deploy del contratto dipendente `TicketNFT` all'interno del blocco `beforeEach` del file `Marketplace.test.js`, nonostante il codice Solidity, la configurazione Hardhat e il codice di test apparissero corretti e funzionassero sia nella console interattiva (`npx hardhat console`) sia in file di test isolati. Il problema è stato risolto identificando una potenziale corruzione dello stato/cache interna di Hardhat legata al file di test originale e ricostruendo il file partendo da una base minimale funzionante. Questo non ha impattato la logica dei contratti ma ha richiesto tempo di debug ambientale.
TicketNFT.sol (packages/contracts/contracts/TicketNFT.sol)
Standard: ERC721 (OpenZeppelin v5.x).
Ownership: Ownable (proprietario iniziale impostato nel costruttore).
Contatore ID: Manuale (`_nextTokenId`).
Dipendenze: Richiede l'indirizzo del contratto `Marketplace.sol` nel costruttore per leggere i parametri delle commissioni di servizio.

Strutture Dati Chiave:
* `ticketData(tokenId => TicketData)`: Memorizza `eventId`, `originalPrice`, `issuanceDate` per ogni NFT mintato.
* `eventCreators(eventId => address payable)`: Mappa l'ID evento all'indirizzo del creatore che riceve il pagamento primario.
* `eventOriginalPrices(eventId => uint256)`: Mappa l'ID evento al prezzo originale (in Wei) stabilito al momento della registrazione.

Funzionalità Principali:
* `constructor(name, symbol, initialOwner, marketplaceAddress)`: Inizializza il contratto.
* `registerEvent(eventId, creatorAddress, originalPrice)`: (Solo Owner) Registra un nuovo evento on-chain, impostando chi riceverà i pagamenti e il prezzo del biglietto. Emette `EventRegistered`. Necessario prima che i biglietti per quell'evento possano essere acquistati tramite `buyAndMintTicket`.
* `buyAndMintTicket(eventId)`: (Pubblica, Payable) Permette a chiunque di acquistare un biglietto per un evento registrato.
    * Recupera prezzo e indirizzo creatore dalle mapping.
    * Legge `serviceFeeBasisPoints` e `serviceWallet` dal contratto `Marketplace` associato.
    * Calcola la commissione di servizio (stessa % del marketplace).
    * Richiede `msg.value == prezzo + commissione`.
    * Distribuisce i fondi: `prezzo` al `creatorAddress`, `commissione` al `serviceWallet`.
    * Minta l'NFT all'acquirente (`msg.sender`).
* `mintTicket(to, eventId, originalPrice)`: (Solo Owner) Funzione originale per mintare biglietti (senza flusso di pagamento diretto nel contratto). Utile per minting da backend/admin (es. biglietti omaggio, importazioni). Richiede che l'evento sia preferibilmente già registrato per coerenza dei dati. Chiama la logica di minting interna.
* `_createTicket(to, eventId, originalPrice)`: (Interna) Logica condivisa per il minting effettivo e il salvataggio dei `ticketData`.
Fase Attuale - Implementazione Flussi di Pagamento Reali & Test:
[...]
Scope Principale:
Smart Contract (TicketNFT.sol, Marketplace.sol):
    * `Marketplace.sol`: Logica acquisto P2P (`buyItem`) modificata per essere `payable`, calcolare commissione servizio (letta da variabili di stato configurabili da owner) e distribuire fondi a venditore e wallet servizio. Test completati e funzionanti (dopo debug ambiente). (FATTO)
    * `TicketNFT.sol`: Modificato per includere logica acquisto primario (`buyAndMintTicket`) `payable`. Aggiunta registrazione eventi on-chain (`registerEvent`) con indirizzo creatore e prezzo. `buyAndMintTicket` legge commissione/wallet da `Marketplace` per coerenza e distribuisce fondi a creatore e wallet servizio prima di mintare. (IMPLEMENTATO, DA TESTARE)
Test Smart Contract: Test per `Marketplace.sol` completati. Da scrivere test per le nuove funzionalità di `TicketNFT.sol` (`registerEvent`, `buyAndMintTicket`). (IN CORSO)
Backend: [...] (Ancora da adattare)
Frontend: [...] (Ancora da adattare)

Prossimo Passo Immediato: Scrivere e eseguire i test Hardhat per le nuove funzionalità del contratto `TicketNFT.sol` (`registerEvent`, `buyAndMintTicket`).
Fase Attuale - Integrazione Backend per Flussi Pagamento:
[...]
Scope Principale:
Smart Contract (TicketNFT.sol, Marketplace.sol): [...] (Implementati e Testati)
Test Smart Contract: Test per `Marketplace.sol` e `TicketNFT.sol` completati. (FATTO)
Backend:
    - Modificata API creazione eventi (`POST /api/events`) per chiamare `registerEvent` su `TicketNFT` on-chain dopo salvataggio DB, usando wallet owner e passando indirizzo creatore/prezzo. (IMPLEMENTATO E TESTATO CON SUCCESSO)
    - Da adattare: Logica acquisto primario (`buyTicket` nel controller/service) per usare `buyAndMintTicket`. (DA FARE)
    - Da adattare: Logica acquisto secondario (`buyItem` nel service) per gestire `msg.value`. (DA FARE)
    - Da definire: API per esporre fee (opzionale). (DA FARE)
Frontend: [...] (Ancora da adattare)

Prossimo Passo Immediato: Verificare/Completare la configurazione Ethers.js nel backend (`config/ethers.js`) con ABI/indirizzo corretti per Amoy. Successivamente, testare end-to-end la creazione evento con registrazione on-chain. Poi, adattare le API di acquisto (primario e secondario).
Nuovo indirizzo TicketNFT.sol:0x64afF703E9A973A55cf23ecb616768930454a2b6
Nuovo indirizzo Marketplace.sol:0xDE1A30f6AC4093B78b0409ED08e47B67aE845732
Prossimo Passo Immediato: Modificare eventController.js (buyTicket) e eventService.js (creare/modificare funzione per acquisto primario) per implementare la chiamata alla funzione buyAndMintTicket del contratto TicketNFT, includendo recupero chiave utente, calcolo valore totale (prezzo+fee) e invio della transazione payable: "Invece di modificare subito la funzione esistente (mintTicketForUser, se esiste), creeremo una nuova funzione asincrona chiamata purchasePrimaryTicket. Questo ci permette di costruire la nuova logica senza rompere quella vecchia (che comunque non useremo più per l'acquisto standard)." -> funzione implementata con successo in eventSuccess.js.
Dopo questo ultimo passaggio: "Punto Chiave da Affrontare:

La parte più complessa qui è userService.getUserSigner(userId). Come recuperi e decripti la chiave privata dell'utente? Hai già una logica per questo in userService.js o dobbiamo crearla? Questo dipende da come hai implementato la crittografia delle chiavi menzionata nel compendio ([source: 103]).
"Cosa Manca per purchasePrimaryTicket:

Guardando la logica che abbiamo definito per la nuova funzione purchasePrimaryTicket, mancano due import fondamentali:

marketplaceContract: La nuova funzione deve leggere le commissioni (serviceFeeBasisPoints, serviceWallet) dal contratto Marketplace. Devi importare l'istanza del contratto Marketplace da config/ethers.js, esattamente come fai per ticketNFTContract.
userService: La nuova funzione deve recuperare e decriptare la chiave privata dell'utente per creare il userSigner. Questa logica dovrebbe trovarsi nel tuo userService.js (o un file simile). Devi importare quel service.
" -> risolto, vanno bene.
Per ora, puoi aggiungere lo scheletro della funzione purchasePrimaryTicket e possiamo discutere di come implementare la parte getUserSigner o se usare temporaneamente un wallet diverso (come minterWallet) solo per testare il flusso della transazione on-chain."
Conclusione:

ethers.js è pronto e anche userService.js e cryptoUtilis.js
Pronti per riavviare il backend e testare il flusso di acquisto primario (modificando prima il controller eventController.js per chiamare purchasePrimaryTicket invece della vecchia funzione).


Fonti e contenuti correlati
XX. Note Operative e Procedure Manuali

Aggiornamento ABI Contratti nel Backend:
ATTENZIONE: Dopo ogni modifica e ricompilazione degli smart contract (`npx hardhat compile` in `packages/contracts`), è NECESSARIO copiare manualmente i file JSON degli artifact aggiornati (es. `TicketNFT.json`, `Marketplace.json`) dalla directory `packages/contracts/artifacts/contracts/NomeContratto.sol/` alla directory utilizzata dal backend per caricare gli ABI (attualmente `packages/backend/src/contracts/abi/`). Sovrascrivere i file esistenti. La mancata esecuzione di questo passaggio causerà errori di runtime dovuti a disallineamento ABI.

Flusso Acquisto Primario (buyAndMintTicket):
Stato Attuale: La logica backend (`eventService.purchasePrimaryTicket`) tenta di recuperare la chiave privata criptata dell'utente (`encrypted_private_key` dalla tabella `users`), decriptarla per ottenere un signer, e usare quel signer per chiamare la funzione `payable buyAndMintTicket` del contratto `TicketNFT`.
Problema Attuale: Il recupero della chiave privata fallisce per utenti esistenti che non hanno una `encrypted_private_key` valida nel database (risultando in un errore "Chiave privata criptata non trovata"). È necessario testare con un utente registrato tramite il flusso attuale che popola correttamente questo campo.
TODO (Acquisto Primario): Implementare l'estrazione del `tokenId` mintato dai log della ricevuta di transazione e aggiornare correttamente le tabelle `tickets` (inserimento nuovo record) ed `events` (incremento `tickets_minted`) nel database dopo il successo della transazione on-chain all'interno della funzione `purchasePrimaryTicket`.
**Configurazione Wallet Commissioni (Service Wallet):**

La commissione di servizio (definita in basis points, es. 250 per 2.5%) calcolata sia per l'acquisto primario (`TicketNFT.sol`) sia per l'acquisto secondario (`Marketplace.sol`) viene trasferita automaticamente on-chain a un indirizzo designato ("Service Wallet").

* **Lettura Dinamica:** L'indirizzo del Service Wallet e la percentuale di commissione NON sono hardcoded nel contratto `TicketNFT.sol`, ma vengono letti dinamicamente dal contratto `Marketplace.sol` associato al momento della transazione (`buyAndMintTicket` legge `serviceWallet()` e `serviceFeeBasisPoints()` da `Marketplace`).
* **Configurabilità:** L'indirizzo del Service Wallet e la percentuale di commissione nel contratto `Marketplace.sol` possono essere modificati **solo dal proprietario (Owner)** del contratto `Marketplace.sol` chiamando le funzioni `setServiceWallet(address)` e `setServiceFeeBasisPoints(uint256)`.
* **Verifica Attuale:** È importante verificare periodicamente che l'indirizzo configurato on-chain per `serviceWallet` nel contratto `Marketplace.sol` distribuito (`0xDE1A...` su Amoy) sia quello corretto dove la piattaforma intende ricevere le commissioni. (Al [2025-04-20], il log indicava `0x3564...`). Eventuali modifiche richiedono una transazione on-chain da parte dell'owner.
TODO (Acquisto Primario):
    [FATTO] Testare il flusso con un evento sicuramente registrato on-chain.
    [FATTO] Implementare l'estrazione del `tokenId` mintato dai log della ricevuta di transazione.
    [FATTO] Implementare l'aggiornamento delle tabelle `tickets` (INSERT) ed `events` (UPDATE `tickets_minted`) nel database dopo il successo della transazione on-chain all'interno di `purchasePrimaryTicket`.
    [PENDING] Correggere visualizzazione `transactionHash` nel frontend (attualmente mostra "N/D"). Leggere `response.data.details.transactionHash`.
	/api/events:
  POST /: Crea un nuovo evento (Admin/Creator). Richiede `eventMgmtAuthMiddleware`.
      - Salva i dettagli dell'evento nel database PostgreSQL.
      - Avvia la registrazione dell'evento on-chain chiamando `registerEvent` sul contratto `TicketNFT` (usando il wallet owner del backend).
      - **Risponde immediatamente (status 201)** con i dettagli dell'evento creato nel DB e l'hash della transazione on-chain inviata (`onChainTxHash`).
      - La conferma effettiva della transazione on-chain viene gestita e loggata in background dal backend.
	  10. Roadmap Immediata / Lavori in Corso

[...]

Implementazione Backend Acquisto P2P Marketplace: (PRIORITÀ ATTUALE)
    - Obiettivo: Permettere a un utente di acquistare un biglietto listato da un altro utente.
    - API Endpoint: Definire e implementare `POST /api/marketplace/buy/:listingId` (o simile), protetto da autenticazione (`authMiddleware`).
    - Controller (`marketplaceController.js`): Creare la funzione `buyListing` per gestire la richiesta, estrarre `listingId` e `buyerUserId`, chiamare il service e gestire la risposta.
    - Service (`marketplaceService.js`): Creare la funzione `purchaseSecondaryTicket(buyerUserId, listingId)`:
        - Recuperare dettagli listing attivo dal DB (incl. `tokenId`, `seller_wallet_address`, `price`). Validare acquirente != venditore.
        - Recuperare commissione (`serviceFeeBasisPoints`, `serviceWallet`) dal contratto `Marketplace.sol`.
        - Calcolare costo totale (`listingPrice + serviceFee`).
        - Ottenere il `signer` dell'acquirente (`userService.getUserSigner`). Verificare saldo.
        - Chiamare la funzione `payable buyItem(tokenId)` del contratto `Marketplace.sol` con il signer dell'acquirente e il `msg.value` corretto.
        - In caso di successo on-chain (`tx.wait(1)`):
            - Aggiornare DB (in transazione): `UPDATE listings SET is_active = false`, `UPDATE tickets SET owner_user_id = ..., owner_wallet_address = ..., is_listed = false`.
        - Gestire errori (listing non valido, fondi insufficienti, revert contratto, errori DB).
        - Restituire dettagli transazione al controller.

[...]
Implementazione Backend Acquisto P2P Marketplace FATTO.
Implementazione Frontend Acquisto P2P Marketplace FATTO.

XX. Integrazione Wallet Esterno (Fase B - In Corso)

Obiettivo Generale: Permettere agli utenti di utilizzare un wallet esterno (es. MetaMask), quando connesso e selezionato (preferenza 'external'), per firmare ed eseguire direttamente le transazioni blockchain rilevanti (acquisto primario, acquisto/vendita/annullamento P2P), e assicurare che i pagamenti degli eventi creati vadano all'indirizzo corretto (interno o esterno) scelto dal creatore.

Piano di Implementazione (Fasi):

* **Fase B.1: Frontend Marketplace P2P (IN CORSO)**
    * **Obiettivo:** Modificare `MyTicketsView.vue` (per List/Cancel) e `MarketplaceView.vue` (per Buy P2P).
    * **Logica:**
        * Aggiungere controllo su `walletStore.isUsingExternalWallet`.
        * Se `true`:
            * Ottenere `signer` da `walletStore`.
            * Ottenere ABI/Indirizzi dei contratti (`TicketNFT`, `Marketplace`) nel frontend.
            * Creare istanze `ethers.Contract` connesse al `signer`.
            * Chiamare le funzioni del contratto richieste (es. `nftContract.approve`, `marketContract.listItem`, `marketContract.cancelListing`, `marketContract.buyItem` con `{ value: ... }`).
            * Attendere conferma transazione (`tx.wait()`).
            * Aggiornare UI e/o notificare backend/store per refresh dati.
        * Se `false`: Mantenere la logica esistente che chiama le azioni dell'`authStore` (es. `listTicketForSale`, `cancelListing`, `buyFromMarketplace`) che usano il backend per firmare.
    * **Dipendenze:** `stores/wallet.js` (per stato e signer), accesso a ABI/Indirizzi contratti nel frontend.

* **Fase B.2: Frontend Acquisto Primario (SUCCESSIVA)**
    * **Obiettivo:** Modificare la vista/componente per l'acquisto primario (probabilmente `EventsView.vue`).
    * **Logica:** Simile a B.1, ma per la funzione `buyAndMintTicket` del contratto `TicketNFT`.
        * Se `isUsingExternalWallet` è `true`: Ottenere signer, creare istanza `TicketNFT`, calcolare costo totale (prezzo evento + fee letta da `Marketplace`), chiamare `ticketNFTContract.buyAndMintTicket(eventId, { value: totalCost })`, attendere conferma, aggiornare UI/dati (via refresh store o notifica backend).
        * Se `false`: Mantenere logica esistente (`authStore.buyTicket`).

* **Fase B.3: Backend Creazione Evento (SUCCESSIVA)**
    * **Obiettivo:** Assicurare che il pagamento primario vada all'indirizzo corretto scelto dal creatore.
    * **Logica:** Modificare `eventController.js` / `eventService.js`.
        * Quando si gestisce `POST /api/events`, leggere `wallet_preference` e `external_wallet_address` (verificare esistenza colonna DB) dell'utente creatore (`req.user`).
        * Determinare l'`creatorAddress` corretto da passare alla funzione `registerEvent` del contratto `TicketNFT`: se pref='external' usare `external_wallet_address`, altrimenti usare `wallet_address` interno.

In corso: implementazione logica wallet esterno in MyTicketsView.vue. Riscontrato errore importazione configurazione contratti (config.js). Verifica percorso/esistenza file in corso.
Iniziata modifica handleListTicket in MyTicketsView.vue per logica wallet esterno. Risolto errore import config.js. Attualmente bloccato da errore JavaScript runtime che causa pagine bianche. In attesa di analisi errori console browser.
Implementazione logica wallet esterno in MyTicketsView.vue. Bloccato da errore runtime ReferenceError: useWalletStore is not defined. In corso: Correzione importazione store wallet nel componente.
Implementazione logica wallet esterno in handleListTicket (MyTicketsView.vue) completata. Risolti errori runtime (ReferenceError dovuto a incoerenza nomi variabili import ABI JSON). Componente MyTicketsView.vue ora caricato correttamente e pronto per testare il flusso di messa in vendita con wallet esterno.
La funzione handleListTicket ora verifica walletStore.isUsingExternalWallet. Se true, tenta di ottenere il signer da walletStore, istanziare i contratti TicketNFT e Marketplace usando ABI locali e indirizzi da config.js, e chiamare nftContract.approve() seguito da marketContract.listItem() chiedendo conferma a MetaMask per entrambe le transazioni.
Implementazione logica wallet esterno in handleListTicket (MyTicketsView.vue). Bloccato da errore runtime TypeError: Cannot read from private field originato da ethers.js durante provider.getSigner() in ensureSigner. In corso: Test con versione semplificata di ensureSigner che forza ricreazione provider/signer.
Implementazione logica wallet esterno in handleListTicket (MyTicketsView.vue). Bloccato da errore runtime TypeError: Cannot access private method durante chiamata approve. In corso: Debug tramite logging aggiuntivo e chiamata read-only per verificare stato signer/contratto prima della transazione.
Implementazione logica wallet esterno in handleListTicket. Bloccato da errore runtime TypeError: Cannot access private method originato da ethers.js. Ripristinato window.prompt. In corso: Test con versione raffinata di ensureSigner (DEBUG v3) che salva il provider prima di getSigner.
XX. Integrazione Wallet Esterno (Fase B - In Corso)

Obiettivo Generale: [...] (invariato) [cite: 233]

Piano di Implementazione (Fasi):
    * Fase B.1: Frontend Marketplace P2P (List/Cancel da MyTicketsView, Buy da MarketplaceView) (IN CORSO)
        * Obiettivo: Modificare componenti Vue per usare `signer` da MetaMask per transazioni P2P quando `isUsingExternalWallet` è `true`. [cite: 234]
        * Stato Attuale: Implementazione logica condizionale in `handleListTicket` (`MyTicketsView.vue`) per la messa in vendita[cite: 254, 404]. Copiati ABI e indirizzi contratti nel frontend (`src/contracts/`)[cite: 390].
        * **ERRORE BLOCCANTE:** Si verifica un errore persistente `TypeError: Cannot access private method` all'interno di `ethers.js` quando si tenta di chiamare funzioni del contratto (es. `approve`, `listItem`, anche read-only [cite: 410, 412]) utilizzando il `signer` ottenuto da `walletStore.ensureSigner()`[cite: 255, 257, 259, 407].
        * Debug Tentati: Diverse versioni di `ensureSigner` per forzare ricreazione provider/signer[cite: 256, 408], logging aggiuntivo per ispezionare oggetti `signer`/`contract`[cite: 258, 411], ripristino `window.prompt`[cite: 259, 413], raffinamento `ensureSigner`[cite: 260, 414]. Nessuno di questi ha risolto l'errore.
        * **Passi Successivi Immediati:**
            1. Semplificare la funzione `ensureSigner` in `stores/wallet.js`.
            2. Modificare `handleListTicket` per istanziare `ethers.Contract` *localmente* all'interno della funzione, subito prima di chiamare le funzioni del contratto, usando il `signer` appena ottenuto.
            3. Verificare nuovamente e scrupolosamente la correttezza degli ABI JSON e degli indirizzi in `src/contracts/config.js`.
            4. Testare nuovamente il flusso "Vendi" da `MyTicketsView.vue` con wallet esterno.
        * **Da Fare (dopo risoluzione errore):** Implementare logica simile per `handleCancelListing` in `MyTicketsView.vue` e per `handleBuyListing` in `MarketplaceView.vue`.

    * Fase B.2: Frontend Acquisto Primario (SUCCESSIVA) [...] [cite: 242, 387]
    * Fase B.3: Backend Creazione Evento (Payout Address) (SUCCESSIVA) [...] [cite: 245, 388]

XX. Integrazione Wallet Esterno (Fase B - In Corso)

Obiettivo Generale: [...]

Piano di Implementazione (Fasi):
    * Fase B.1: Frontend Marketplace P2P (List/Cancel da MyTicketsView, Buy da MarketplaceView) (IN CORSO)
        * Obiettivo: [...]
        * Stato Attuale: **SUCCESSO** nell'implementazione e test della messa in vendita (`approve` + `listItem`) da `MyTicketsView.vue` utilizzando un wallet esterno (Brave Wallet).
        * **Workaround Chiave:** È stato necessario utilizzare il parametro **legacy `gasPrice`** (ottenuto dinamicamente da `provider.getFeeData()`) negli oggetti transazione passati a `signer.sendTransaction`, poiché Brave Wallet (con `ethers@6.13.5` su Amoy) non gestiva correttamente/ignorava i parametri EIP-1559 (`maxFeePerGas`, `maxPriorityFeePerGas`) forniti, causando errori "transaction underpriced".
        * **Da Fare (Fase B.1):**
            - Applicare lo stesso workaround (uso di `gasPrice` legacy) alle funzioni `handleCancelListing` in `MyTicketsView.vue` e `handleBuyListing` (o nome simile) in `MarketplaceView.vue` per le interazioni con wallet esterno.
            - Testare le funzioni di annullamento e acquisto P2P con wallet esterno.
        * **Problema Aperto (UI/Dati):** La lista "I Miei Biglietti" (`authStore.fetchMyTickets`) attualmente non mostra gli NFT posseduti dal wallet esterno (perché filtra per `owner_user_id` interno). Da affrontare successivamente.

    * Fase B.2: Frontend Acquisto Primario (SUCCESSIVA) [...]
    * Fase B.3: Backend Creazione Evento (Payout Address) (SUCCESSIVA) [...]
	XX. Integrazione Wallet Esterno (Fase B - In Corso)

Obiettivo Generale: [...]

Piano di Implementazione (Fasi):
    * Fase B.1: Frontend Marketplace P2P (List/Cancel da MyTicketsView, Buy da MarketplaceView) (IN CORSO)
        * Obiettivo: [...]
        * Stato Attuale:
            - **Trasferimento NFT per Test:** Trasferito manualmente NFT (ID 9) da wallet interno a wallet esterno (`0x356...`) tramite script backend dedicato per abilitare test di proprietà corretta. DB aggiornato manualmente. [cite: 1]
            - **Debug Invio Transazioni (Brave Wallet):** Riscontrati errori persistenti (`TypeError: Cannot access private method`, `execution reverted`, `transaction underpriced: gas tip cap 0`) durante l'invio di transazioni (`approve`, `listItem`) da Brave Wallet via `ethers@6.13.5`. [cite: 1]
            - **Workaround Trovato:** L'invio di transazioni funziona specificando il parametro **legacy `gasPrice`** (ottenuto da `provider.getFeeData()`) nell'oggetto transazione passato a `signer.sendTransaction`. L'uso dei parametri EIP-1559 (`maxFeePerGas`, `maxPriorityFeePerGas`) sembrava essere ignorato o mal gestito da Brave Wallet su Amoy in questo contesto. [cite: 1]
            - **Listing Esterno:** Implementata e testata con **successo** la messa in vendita (`handleListTicket` in `MyTicketsView.vue`) per un NFT posseduto dal wallet esterno, usando il workaround `gasPrice`. [cite: 1]
            - **Annullamento Esterno:** Implementata logica (`handleCancelListing` in `MyTicketsView.vue`) con workaround `gasPrice`. (DA TESTARE).
            - **Acquisto Esterno:** Implementata logica (`handleBuy` in `MarketplaceView.vue`) con workaround `gasPrice`. Risolto `ReferenceError: walletStore is not defined`. (DA TESTARE).
        * **Da Fare (Fase B.1):**
            - Testare end-to-end le funzioni di annullamento e acquisto P2P con wallet esterno.
        * **Problemi Aperti:**
            - **Visibilità Listing:** Il listing creato on-chain (Token 9) non appare nella vista Marketplace. Probabilmente manca la notifica/salvataggio nel DB backend dopo il successo della transazione `listItem` esterna. Da investigare (Controllare DB `listings` -> Modificare `handleListTicket` per notificare backend). [cite: 1]
            - **Visibilità "I Miei Biglietti":** La vista `MyTicketsView.vue` (via `authStore.fetchMyTickets`) attualmente non mostra gli NFT posseduti dall'indirizzo esterno connesso. Richiede modifica della logica di fetch/visualizzazione per wallet esterno. [cite: 1]

    * Fase B.2: Frontend Acquisto Primario (SUCCESSIVA) [...]
    * Fase B.3: Backend Creazione Evento (Payout Address) (SUCCESSIVA) [...]
	XX. Integrazione Wallet Esterno (Fase B - In Corso)
[...]
    * Fase B.1: Frontend Marketplace P2P (List/Cancel da MyTicketsView, Buy da MarketplaceView) (IN CORSO)
        * Stato Attuale:
            - [...] (Info su Listing Esterno e Workaround gasPrice)
            - **Acquisto Esterno:** Implementata e testata con **successo** la funzione di acquisto (`handleBuy` in `MarketplaceView.vue`) per un NFT listato, usando il wallet esterno (Brave Wallet). È stato necessario:
                - Usare il workaround `gasPrice` legacy per compatibilità con Brave Wallet.
                - Calcolare la commissione di servizio (leggendo `serviceFeeBasisPoints` dal contratto Marketplace).
                - Inviare il `totalValueToSend = listingPrice + commissionAmount` nel campo `value` della transazione `buyItem`.
        * **Da Fare (Fase B.1):**
            - Implementare il workaround `gasPrice` legacy nella funzione `handleCancelListing` in `MyTicketsView.vue`.
            - Testare end-to-end la funzione di annullamento listing con wallet esterno.
        * **Problemi Aperti:**
            - **Visibilità Listing:** Il listing creato esternamente (Token 9) non appare. Investigare: 1) Controllare DB `listings`. 2) Se manca, modificare `handleListTicket` per notificare/salvare il listing nel backend dopo successo on-chain.
            - **Visibilità "I Miei Biglietti":** `MyTicketsView.vue` non mostra NFT posseduti dall'indirizzo esterno. Richiede modifiche fetch/visualizzazione.
[...]
/api/marketplace:
    [...]
    POST /notify-external-listing: (Nuovo) Riceve notifica dal frontend dopo successo on-chain di un listing eseguito con wallet esterno. Richiede auth (`protect`). Body: { tokenId, nftContractAddress, listingPrice, sellerAddress, transactionHash? }. Aggiorna DB `listings` e `tickets`.
	XX. Integrazione Wallet Esterno (Fase B - In Corso)
[...]
    * Fase B.1: Frontend Marketplace P2P (List/Cancel/Buy) (IN CORSO)
        * Stato Attuale:
            - [...] (Info su Transfer NFT, Workaround gasPrice, Successo List/Buy on-chain)
            - **Gestione Cache DB Backend:** Implementata logica backend per sincronizzare il DB dopo operazioni esterne:
                - Creato endpoint API `POST /api/marketplace/notify-external-listing` (protetto).
                - Implementata logica in `marketplaceService` (`processExternalListingNotification`) per ricevere dati dal frontend, recuperare info mancanti e fare UPSERT su `listings` + UPDATE su `tickets`.
        * **Da Fare (IMMEDIATO):**
            - **Frontend:** Modificare `handleListTicket` in `MyTicketsView.vue` per chiamare la nuova API `/notify-external-listing` *dopo* la conferma on-chain della transazione `listItem` esterna.
        * **Da Fare (Successivo Fase B.1):**
            - Implementare e testare il workaround `gasPrice` legacy in `handleCancelListing`. Aggiungere chiamata a API backend di notifica simile (`/notify-external-cancel`?) dopo successo on-chain.
            - Implementare e testare workaround e notifica backend (`/notify-external-purchase`?) in `handleBuy`.
        * **Problemi Aperti:**
            - **Visibilità "I Miei Biglietti":** `MyTicketsView.vue` non mostra NFT posseduti dall'indirizzo esterno. Richiede modifiche fetch/visualizzazione. (Priorità post-notifiche backend).
[...]
XX. Integrazione Wallet Esterno (Fase B - In Corso)
[...]
    * Fase B.1: Frontend Marketplace P2P (List/Cancel/Buy) (IN CORSO - BLOCCATO)
        * Stato Attuale:
            - [...] (Info su Transfer NFT, Workaround gasPrice, Successo Acquisto)
            - **Listing Esterno:**
                - Risolto `TypeError` frontend relativo alla chiamata API di notifica backend (usando `axios.post` diretto).
                - Testato listing NFT (posseduto da wallet esterno) da `MyTicketsView.vue` usando workaround `gasPrice`.
                - Transazione `approve` **OK**.
                - Transazione `listItem` **FALLISCE ON-CHAIN (REVERTED)**.
        * **Da Fare (IMMEDIATO):**
            - **Diagnosticare Revert `listItem`:** Analizzare codice Solidity di `Marketplace.sol::listItem` o verificare stato on-chain (listing esistente? approvazione ancora valida?) per capire la causa del revert. <-- SIAMO QUI
        * **Da Fare (Successivo Fase B.1 - dopo fix listItem):**
            - Implementare chiamata frontend a API backend `/notify-external-listing` dopo successo `listItem`.
            - Implementare e testare `handleCancelListing` (con workaround `gasPrice` e notifica backend).
        * **Problemi Aperti:**
            - Visibilità Listing/Biglietti esterni nella UI. (Priorità post-interazioni funzionanti).
[...]
Stato Attuale (Compendio - Sezione Integrazione Wallet Esterno / Debug)

Blocco: La transazione listItem chiamata dal frontend (MyTicketsView.vue) usando un wallet esterno fallisce on-chain (reverted) dopo che la transazione approve ha avuto successo.   
Diagnosi in Corso: Tentativo di diagnosticare la causa del revert analizzando lo stato on-chain (getApproved su TicketNFT, listings su Marketplace) per il token ID specifico.
Verifica Contratti: Entrambi i contratti (TicketNFT all'indirizzo 0x64af... e Marketplace all'indirizzo 0xDE1A...) sono stati verificati con successo su Amoy Polygonscan tramite il plugin npx hardhat verify dopo aver risolto problemi relativi alla posizione del file .env e alla necessità di fornire gli argomenti del costruttore.
Problema Interfaccia Polygonscan: L'interfaccia web di Polygonscan non riflette lo stato verificato dei contratti (al [24/04/2025 13:16 CEST]), impedendo l'uso diretto della funzione "Read Contract" del sito.
Prossimo Passo Immediato: Eseguire i controlli on-chain necessari (getApproved, listings) utilizzando la console Hardhat (npx hardhat console --network amoy) per bypassare i problemi dell'interfaccia Polygonscan.
Stato Attuale (Compendio - Sezione Integrazione Wallet Esterno / Debug)

Blocco: La transazione listItem chiamata dal frontend (MyTicketsView.vue, tramite pulsante di test dedicato) usando un wallet esterno per un NFT trasferito (es. Token ID 3) fallisce on-chain (reverted), nonostante approve venga confermata nel frontend (wait(1) presente e corretto nel codice).
Diagnosi in Corso:
Analisi precedente con console Hardhat per Token ID 3 ha mostrato getApproved = indirizzo zero, suggerendo un problema di visibilità/persistenza dell'approvazione o timing RPC.
Test con Token ID 5 (usando erroneamente pulsante test) ha confermato che approve passa (wait(1)) ma listItem fallisce subito dopo, rafforzando l'ipotesi di problemi di stato on-chain (Price Cap?) o timing/propagazione RPC.
Confermato che la lista UI (authStore.myTickets) non mostra NFT esterni, richiedendo l'uso di un pulsante di test per handleListTicket con token esterni. Questo è un problema UI/fetch dati da risolvere separatamente.
Prossimo Passo Immediato:
Verificare on-chain (via Hardhat console) il originalPrice del Token ID 3 (per escludere violazione Price Cap del pulsante test).
Verificare on-chain (via Hardhat console) lo stato getApproved attuale per Token ID 3.
Aggiungere un delay artificiale (es. 2 secondi) nel codice frontend (handleListTicket) tra la conferma di approve e l'invio di listItem per mitigare potenziali ritardi di propagazione RPC.
Ritestare il listing del Token ID 3 usando il pulsante di test modificato e il codice con delay.
Stato Attuale (Compendio - Sezione Integrazione Wallet Esterno / Debug)

PROGRESSO: Il listing on-chain (listItem) da wallet esterno ora funziona dopo aver introdotto un delay artificiale di 2 secondi nel frontend (handleListTicket in MyTicketsView.vue) tra la conferma della transazione approve e l'invio della transazione listItem. Questo conferma che il revert precedente era causato da ritardi di propagazione dello stato/RPC.
Nuovo Blocco: La successiva chiamata API dal frontend al backend (POST /api/marketplace/notify-external-listing) per registrare il listing nel DB fallisce con errore 404 Not Found.
Causa 404: La chiamata Axios nel frontend usa un URL relativo (/api/...) che punta erroneamente al server frontend (localhost:5173) invece del server backend (localhost:3000).
Prossimo Passo Immediato: Correggere la chiamata axios.post in MyTicketsView.vue per usare l'URL completo del backend (http://localhost:3000/api/...) e ritestare il flusso di listing esterno completo (inclusa la notifica).
Stato Attuale (Compendio - Sezione Integrazione Wallet Esterno / Debug)

Listing Esterno Funzionante: Il listing on-chain (listItem) da wallet esterno funziona dopo aver aggiunto un delay di 2s nel frontend tra approve.wait(1) e l'invio di listItem.
Notifica Backend (Listing): Identificato e corretto (o in corso di correzione) l'URL per la chiamata API POST /api/marketplace/notify-external-listing dal frontend al backend.
Prossimo Passo Sviluppo (Fase B.1):
Implementare la logica completa per handleCancelListing in MyTicketsView.vue per wallet esterni (inclusi gasPrice workaround, wait(1), e chiamata a nuova API backend di notifica /notify-external-cancel). Richiede creazione endpoint/logica backend.
(Opzionale/Verifica) Assicurare che handleBuy in MarketplaceView.vue notifichi il backend dopo un acquisto esterno riuscito (creando endpoint/logica se necessario).
(Parallelo/Successivo) Risolvere il problema della mancata visualizzazione dei biglietti/listing associati al wallet esterno nelle viste "I Miei Biglietti" e "Marketplace".