[Inizio Sessione] - Discussione Funzionalità Future: Abbiamo discusso le idee future post-MVP, scegliendo di concentrarci su:

Integrazione Wallet Esterni (Non-Custodial)
Creazione Eventi/NFT da UI
[~16:00 CEST] - Definizione Modello Ibrido Wallet: Hai chiarito di volere un sistema ibrido: gli utenti possono collegare un wallet esterno oppure usare un wallet interno gestito dal backend (custodial), per mantenere un'esperienza semplice per i neofiti.

[~16:05 CEST] - Avvio Fase A (Integrazione Wallet Esterno - Frontend): Abbiamo deciso di iniziare implementando la possibilità di collegare wallet esterni nel frontend Vue.

[~16:05 CEST] - Proposta Store Pinia: Ho fornito il codice iniziale per uno store Pinia (useWalletStore) da salvare in stores/wallet.js per gestire lo stato del wallet.

[~16:08 CEST] - Identificazione Componente UI: Dopo aver verificato che non esisteva un Navbar.vue dedicato, abbiamo identificato App.vue come il componente corretto dove inserire l'UI per la connessione del wallet (pulsante, stato).

[~16:10 CEST] - Prima Modifica App.vue: Ti ho fornito le modifiche per App.vue per importare e usare useWalletStore e aggiungere il blocco HTML/Vue per il pulsante "Collega Wallet" e lo stato della connessione nella navbar.

[~16:15 CEST] - Tentativo Push e Errore Git: Hai applicato le modifiche e hai tentato di fare git push, ma hai ricevuto l'errore rejected (fetch first) perché il repository remoto era più avanti di quello locale.

[~16:16 CEST] - Risoluzione Errore Git (pull/merge): Ti ho guidato nell'eseguire git pull origin main e nel confermare il messaggio del commit di merge che si è aperto nell'editor.

[~16:18 CEST] - Richiesta Annullamento Modifiche: Hai deciso di annullare le modifiche appena caricate su GitHub per poter testare meglio localmente prima.

[~16:20 CEST] - Annullamento Modifiche (revert): Ti ho guidato nel processo di git revert:

Identificazione dell'hash del commit da annullare (git log).
Esecuzione di git revert <hash>.
Conferma del messaggio del commit di revert nell'editor.
Esecuzione di git push origin main per caricare l'annullamento su GitHub e aggiornare i file locali allo stato precedente.
[~16:22 CEST] - Riavvio Implementazione Fase A (Locale):

Hai ricreato il file stores/wallet.js.
Hai fornito di nuovo il contenuto (revertito) di App.vue.
Ti ho fornito nuovamente le modifiche per App.vue (import store, uso store, UI wallet) con indicatori più chiari nel codice.
[~16:25 CEST] - Test Locale Positivo: Hai applicato le modifiche ad App.vue, avviato l'ambiente locale e confermato che il pulsante "Collega Wallet" ora è visibile, non ci sono errori nel terminale/console, e la connessione a MetaMask funziona correttamente.
[2025-04-18 16:37 CEST] - Aggiornamento Fase A: Risolto problema di disconnessione al cambio account. L'indirizzo nella UI ora si aggiorna correttamente (deferito aggiornamento del signer). Errore asincrono in console presente ma non bloccante.
[2025-04-18 16:43 CEST] - Aggiornamento Fase A: Implementata logica setUserWalletPreference nello store e UI temporanea in App.vue per testare la scelta tra wallet interno/esterno. Test locale conferma che la visibilità della sezione wallet esterno dipende correttamente dallo stato isUsingExternalWallet.
[2025-04-18 16:56 CEST] - Aggiornamento Fase A: Implementato flusso v2 per wallet ibrido. Rimossi controlli di test. Modificati App.vue e wallet.js per usare connect/disconnect come meccanismo di switch tra contesto wallet interno (default) ed esterno. Test locale conferma funzionamento base.
[2025-04-18 17:05 CEST] - Aggiornamento Fase A: Aggiunta funzione ensureSigner allo store useWalletStore (wallet.js) per verificare/aggiornare il signer del wallet esterno prima delle azioni future. Funzione definita ma non ancora utilizzata.
[2025-04-18 17:10 CEST] - Aggiornamento Persistenza Wallet: Modificata localmente tabella users in PostgreSQL aggiungendo colonna wallet_preference TEXT DEFAULT 'internal' NOT NULL.
[2025-04-18 17:16 CEST] - Aggiornamento Persistenza Wallet: Modificato backend (userService, authController) per leggere la colonna wallet_preference dal DB e includerla nella risposta API di login.
[2025-04-18 17:41 CEST] - Aggiornamento Ambiente: Configurato ambiente di sviluppo completamente locale: Frontend punta a Backend locale (http://localhost:3000), Backend punta a Database PostgreSQL locale.
[2025-04-18 17:47 CEST] - Aggiornamento Persistenza Wallet & Bugfix: Risolto errore TypeError: walletStore.resetState is not a function modificando logout in auth.js per chiamare disconnectWallet. Corretto funzionamento di login, logout e inizializzazione preferenza wallet nell'ambiente locale verificato.
[2025-04-18 17:58 CEST] - Aggiornamento Persistenza Wallet: Modificato App.vue per nascondere la sezione UI del wallet esterno se walletStore.isUsingExternalWallet è false. Test locale conferma che dopo il login con preferenza 'internal', la sezione wallet è correttamente nascosta.
[2025-04-18 18:05 CEST] - Aggiornamento Persistenza Wallet: Creata route /settings, link in App.vue e componente SettingsView.vue. Implementata UI e logica frontend in SettingsView.vue per visualizzare stato wallet (interno/esterno) e switchare modalità tramite connectWallet/disconnectWallet dello store. Test locale UI OK.
[2025-04-18 21:01 CEST] - Aggiornamento Persistenza Wallet: Completata implementazione e test della persistenza della preferenza wallet. L'utente può cambiare modalità (Interno/Esterno) dalla pagina Impostazioni, la scelta viene salvata nel DB tramite API backend e viene caricata correttamente al login successivo, aggiornando lo stato e la UI del frontend come previsto.
[2025-04-18 21:40 CEST] - Aggiornamento SIWE & DB: Aggiunta colonna external_wallet_address (TEXT NULL UNIQUE) e reso password_hash NULLable nella tabella users del DB locale. Implementata e esportata funzione findOrCreateUserByAddress in userService.js per gestire lookup/creazione utenti basata su indirizzo esterno. Backend pronto per verifica SIWE.
[2025-04-18 22:18 CEST] - Rimozione Aggiornamento SIWE: Annullata l'implementazione di SIWE etc riportato i file e il progetto alle condizioni prima di Aggiornamento SIWE & DB.
[2025-04-18 22:28 CEST] - Bugfix Login: Risolto problema login standard non funzionante reinserendo la funzione handleLogin mancante nel componente LoginView.vue. Login username/password ora funzionante.
[2025-04-19 10:32 CEST] - Feature Creazione Eventi: Aggiunto ruolo admin (colonna `is_admin` su `users` DB) e middleware di autorizzazione (`adminAuthMiddleware.js`). Aggiornata API login per restituire stato admin.
[2025-04-19 11:37 CEST] - Bugfix Creazione Eventi: Corretto percorso di import per l'istanza Axios in CreateEventView.vue (da @/services/api a @/axios-config).
[2025-04-19 11:42 CEST] - Bugfix Backend: Corretto l'uso dell'oggetto pool del database in adminAuthMiddleware.js per risolvere TypeError: db.query is not a function.
[2025-04-19 11:47 CEST] - Debug Creazione Eventi: Riscontrato errore 400 Bad Request dal backend con messaggio "Missing required event fields". Iniziata verifica middleware express.json, nomi campi payload e logica controller backend.
[2025-04-19 11:50 CEST] - Bugfix Creazione Eventi: Corretta discrepanza nome campo tra frontend (total_tickets) e backend (totalTickets) per risolvere errore 400 Bad Request. Modificato frontend per inviare totalTickets.
[2025-04-19 11:53 CEST] - Debug Creazione Eventi: Riscontrato nuovo errore TypeError: db.query is not a function in eventService.js. Causa identificata come import/uso errato del pool DB.
[2025-04-19 11:58 CEST] - Debug Creazione Eventi: Riscontrato errore DB colonna "image_url" non esiste. Identificata discrepanza tra query INSERT in eventService.js e schema tabella events. Proposte opzioni: aggiungere colonna al DB o rimuoverla dalla query.
[2025-04-19 12:04 CEST] - Fix Creazione Eventi: Corretto messaggio di successo in CreateEventView.vue per usare response.data.event.name e response.data.event.event_id.
[2025-04-19 12:04 CEST] - Feature Creazione Eventi: Aggiunto campo "Descrizione" al form e alla logica di CreateEventView.vue.
[2025-04-19 12:11 CEST] - Fix Visualizzazione Prezzi: Modificato EventsView.vue per usare ethers.formatEther e mostrare i prezzi degli eventi (letti da original_price in Wei) correttamente in MATIC.
[2025-04-19 12:17 CEST] - Feature Creazione Eventi: Completata implementazione e debugging end-to-end. Funzionalità confermata.
[2025-04-19 ~12:25 CEST] - Feature Ruolo Creator: Aggiunta colonna `is_creator` (BOOLEAN DEFAULT false NOT NULL) a tabella `users` nel DB PostgreSQL.
[2025-04-19 ~12:27 CEST] - Feature Ruolo Creator: Rinominato middleware `adminAuthMiddleware.js` in `eventMgmtAuthMiddleware.js`. Modificato per selezionare `is_creator` dal DB e permettere accesso se `user.is_admin` O `user.is_creator`. Aggiunto `isCreator` a `req.user`.
[2025-04-19 ~12:28 CEST] - Feature Ruolo Creator: Aggiornata route `POST /api/events` in `eventRoutes.js` per usare il nuovo middleware `eventMgmtAuthMiddleware`.
[2025-04-19 ~12:30 CEST] - Feature Ruolo Creator: Aggiornata API `POST /api/auth/login` (in `authController.js`) per includere lo stato `is_creator` nel payload del JWT e nell'oggetto `user` della risposta JSON.
[2025-04-19 ~13:23 CEST] - Bugfix Backend: Corretto endpoint `GET /api/auth/me` (in `authController.js`) per recuperare dal DB e restituire correttamente lo stato `is_creator` dell'utente nella risposta JSON.
[2025-04-19 ~13:25 CEST] - Feature Ruolo Creator: Aggiornato store Pinia `stores/auth.js`: aggiunto stato `isCreator`, modificata azione `WorkspaceUser` per salvarlo, resettato in `logout`, esposto dallo store.
[2025-04-19 ~13:28 CEST] - Feature Ruolo Creator: Consolidato e corretto router guard (`router/index.js`) in un unico `beforeEach`. Modificata logica per rotte `meta.requiresAdmin` per consentire accesso se `authStore.isAdmin` O `authStore.isCreator`.
[2025-04-19 ~13:30 CEST]` - Fix UI: Aggiornato `v-if` per link/pulsante "Crea Evento" (in `App.vue` o navbar) per mostrarlo se `authStore.isLoggedIn && (authStore.isAdmin || authStore.isCreator)`.
[2025-04-19 ~13:35 CEST] - Feature Registrazione Creator: Aggiunta checkbox "Registrati come Organizzatore" in `RegisterView.vue` e aggiornata logica `handleRegister` per inviare il flag.
[2025-04-19 ~13:35 CEST] - Feature Registrazione Creator: Modificata API `POST /api/auth/register` (in `authController.js`) per accettare flag `registerAsCreator`.
[2025-04-19 ~13:35 CEST] - Feature Registrazione Creator: Modificata azione `register` in `authStore` per inviare il flag `registerAsCreator` al backend.
[2025-04-19 ~13:48 CEST] - Bugfix Backend: Risolto `ReferenceError: authService is not defined` in `authController.js` aggiungendo l'import mancante per il service corretto (`userService.js`).
[2025-04-19 ~13:51 CEST]` - Bugfix Backend: Corretta query `INSERT` in `userService.createUser` per includere colonne/placeholders/valori mancanti (`is_admin`, `is_creator`, `wallet_preference`) e risolvere errore mismatch parametri (`bind message provides 5 parameters, but prepared statement "" requires 4`).
[2025-04-19 ~13:53 CEST]` - Feature Registrazione Creator: Completata implementazione e test della registrazione utente con opzione Creator.
[2025-04-19 ~15:30 CEST] - Debug Hardhat Tests: Riscontrato errore persistente "incorrect number of arguments to constructor" durante il deploy di `TicketNFT` nel `beforeEach` di `Marketplace.test.js`, nonostante codice e configurazione apparissero corretti.
[2025-04-19 ~15:40 CEST] - Debug Hardhat Tests: Isolate le cause potenziali: escluso codice Solidity, configurazione Hardhat, dipendenze corrotte (via reinstallazione node_modules), versione Node/npm, backend in esecuzione.
[2025-04-19 ~15:55 CEST] - Debug Hardhat Tests: Il deploy di `TicketNFT` funzionava correttamente in `npx hardhat console` e in un file di test minimale separato (`SimpleDeploy.test.js`), ma falliva nel contesto di `Marketplace.test.js` (anche con codice minimale o dopo rinomina).
[2025-04-19 ~16:10 CEST] - Debug Hardhat Tests: Identificato il problema come uno stato/cache corrotto legato al file `Marketplace.test.js` originale nell'ambiente `npx hardhat test`.
[2025-04-19 ~16:15 CEST] - Sviluppo Test: Risolto il problema di deploy nel test sovrascrivendo `Marketplace.test.js` con il codice minimale funzionante (originariamente da `SimpleDeploy.test.js`) e rinominando il describe block principale.
[2025-04-19 ~16:20 CEST] - Sviluppo Test: Ricostruito gradualmente il blocco `beforeEach` in `Marketplace.test.js`, includendo deploy di `TicketNFT`, deploy di `Marketplace`, minting del token di test e approvazione da parte del seller. Il setup completo ora viene eseguito correttamente.
[2025-04-19 ~16:23 CEST] - Sviluppo Test: Ripristinati e verificati i test case per `Deployment`, `Listing Items`, `Buying Items`, `Canceling Listings` e `Owner Functions` all'interno di `Marketplace.test.js`.
[2025-04-19 ~15:40 CEST] - Sviluppo Smart Contract: Avviata implementazione flusso pagamento primario (minting con commissione) in `TicketNFT.sol`.
[2025-04-19 ~15:45 CEST] - Sviluppo Smart Contract: Scelte di design per `TicketNFT.sol`:
    - Creata nuova funzione `public payable buyAndMintTicket(eventId)` per acquisto utente.
    - Mantenuta `mintTicket(...)` come `onlyOwner` per minting controllato.
    - Aggiunta funzione `onlyOwner registerEvent(eventId, creatorAddress, originalPrice)` per registrare eventi on-chain.
    - Aggiunte mapping `eventCreators` e `eventOriginalPrices`.
    - `TicketNFT` leggerà percentuale commissione e wallet servizio dal contratto `Marketplace` associato per coerenza.
    - Aggiunto riferimento immutabile a `Marketplace` nel costruttore di `TicketNFT`.
[2025-04-19 ~16:35 CEST] - Sviluppo Smart Contract: Implementate modifiche in `TicketNFT.sol`: aggiunti import, variabili stato (marketplaceContract, mapping eventi), evento `EventRegistered`, costruttore aggiornato, funzioni `registerEvent`, `_createTicket` (internal), `buyAndMintTicket` (payable), `mintTicket` (refactoring per usare _createTicket). Utilizzo di `.call{value: ...}("")` per trasferimenti ETH.
[2025-04-19 15:38 CEST] - Sviluppo Smart Contract: Compilazione di `TicketNFT.sol` aggiornato completata con successo.
[2025-04-19 ~16:55 CEST] - Sviluppo Backend: Modificato `eventController.js` (`createEvent`) per recuperare `creatorAddress` da `req.user` e passarlo a `eventService`.
[2025-04-19 ~17:00 CEST] - Sviluppo Backend: Modificato `eventService.js` (`createEvent`) per:
    - Accettare `creatorAddress`.
    - Dopo l'inserimento dell'evento nel DB, chiamare la funzione `registerEvent(eventId, creatorAddress, originalPrice)` sullo smart contract `TicketNFT` usando il wallet owner (da .env).
    - Aggiunta gestione base degli errori per la chiamata on-chain (logging).
[2025-04-19 ~17:01 CEST] - Sviluppo Backend: Identificata necessità di verificare/configurare `config/ethers.js` per esportare correttamente provider, owner wallet (minterWallet) e istanza contratto `ticketNFTContract` con indirizzo/ABI corretti per la rete Amoy.
[2025-04-20 ~11:55 CEST] - Sviluppo Backend: Risolti errori di avvio (`SyntaxError: Identifier '...' has already been declared` per `pool` e `minterWallet`) in `eventService.js` rimuovendo dichiarazioni duplicate.
[2025-04-20 ~11:56 CEST] - Sviluppo Backend: Corretto file `config/ethers.js` per inizializzare ed esportare correttamente `minterWallet` (owner signer) leggendo `PRIVATE_KEY` da `.env`.
[2025-04-20 ~11:57 CEST] - Sviluppo Backend: Backend avviato con successo dopo le correzioni. Pronto per testare l'endpoint `POST /api/events` e la chiamata on-chain `registerEvent`.
[2025-04-20 ~11:50 CEST] - Bugfix Backend: Modificato `eventMgmtAuthMiddleware.js` per recuperare anche `wallet_address` dal DB e aggiungerlo come `walletAddress` all'oggetto `req.user`.
[2025-04-20 ~11:49 CEST] - Test Funzionale: Eseguito test end-to-end per `POST /api/events`. Creazione evento nel DB e chiamata on-chain `registerEvent` a `TicketNFT` (Amoy) completate con successo.
[2025-04-20 ~12:49 CEST] - Fix Deploy & Config: Corretto script deploy.js per gestire dipendenza circolare TicketNFT<->Marketplace e costruttori; modificato TicketNFT.sol (rimosso immutable, aggiunto setter); rieseguiti deploy; aggiornati indirizzi/ABI/chiave owner nel backend.
[2025-04-20 ~12:49 CEST] - Test Funzionale E2E: Eseguito test end-to-end per `POST /api/events` dopo correzioni deploy/config. Creazione evento DB (ID 12) e chiamata+conferma on-chain `registerEvent` (tx: 0xb343...) completate con SUCCESSO.
[2025-04-20 ~12:55 CEST] - Sviluppo Backend: Inizio adattamento flusso acquisto primario (API POST /api/events/:eventId/buy). L'obiettivo è modificare controller/service per usare la funzione payable buyAndMintTicket(eventId) del contratto TicketNFT, gestendo il recupero chiave utente, calcolo costo+fee e invio transazione con msg.value.
[2025-04-20 ~20:10 CEST] - Fix Configurazione Contratti: Risolto errore `marketplaceContract.serviceFeeBasisPoints is not a function` assicurando che gli ABI JSON aggiornati (da `packages/contracts/artifacts/...`) siano copiati manualmente nella directory `packages/backend/src/contracts/abi/` dopo ogni ricompilazione/deploy dei contratti. Verificato anche l'indirizzo del contratto nel file `.env` e riavviato il backend.
[2025-04-20 ~20:10 CEST] - Debug Acquisto Primario: Identificato nuovo errore nel flusso `purchasePrimaryTicket`: `Error: Chiave privata criptata non trovata per l'utente X`. L'errore si verifica in `userService.getUserSigner` quando si tenta di recuperare la chiave privata dell'utente dal DB per firmare la transazione on-chain. Causa probabile: dati incompleti per l'utente di test nel DB (chiave `NULL`).
[2025-04-20 ~20:36 CEST] - Fix Aggiornamento DB Tickets: Risolto errore DB `"la colonna "ticket_id" non esiste"` modificando la query `INSERT INTO tickets` in `eventService.js` (funzione `purchasePrimaryTicket`) per usare `RETURNING db_ticket_id`, corrispondente al nome effettivo della colonna nel DB locale.
[2025-04-20 ~20:36 CEST] - Completamento Flusso Acquisto Primario (Backend): Il flusso API `POST /api/events/:eventId/buy` è ora completo e funzionante. Include: chiamata on-chain `buyAndMintTicket` firmata dall'utente, estrazione del `tokenId` dai log della transazione e aggiornamento delle tabelle `tickets` (INSERT) e `events` (UPDATE `tickets_minted`) nel DB.
[2025-04-20 ~21:10 CEST] - Fix Asynchronous Event Creation: Risolto `ReferenceError: serviceResult is not defined` in `eventController.js` rinominando correttamente la variabile che riceve il risultato da `eventService.createEvent`.
[2025-04-20 ~21:10 CEST] - Successo Gestione Asincrona Creazione Evento: L'API `POST /api/events` ora gestisce la registrazione on-chain (`registerEvent`) in modo asincrono. Salva l'evento nel DB, invia la transazione on-chain e restituisce immediatamente la risposta al frontend (con i dati dell'evento e l'hash della transazione), risolvendo il problema del timeout. La conferma della transazione on-chain viene loggata in background.
[2025-04-20 ~21:14 CEST] - Prossimo Passo Definito: Avvio implementazione backend per acquisto secondario (Marketplace P2P). Focus sulla logica API e service per `POST /api/marketplace/buy`.
[2025-04-22 ~16:59 CEST] - Sviluppo Backend P2P: Implementata logica service purchaseSecondaryTicket in marketplaceService.js (recupero listing/fee, chiamata buyItem con signer acquirente, aggiornamento DB).
[2025-04-22 ~16:59 CEST] - Bugfix Backend P2P: Corretto recupero listing in purchaseSecondaryTicket per usare listingId e indirizzo contract NFT corretto nel WHERE.
[2025-04-22 ~16:59 CEST] - Bugfix Backend P2P: Aggiunto import mancante di userService in marketplaceService.js.
[2025-04-22 ~16:59 CEST] - Test Backend P2P: Eseguito test end-to-end con successo per API POST /api/marketplace/buy/:listingId. Acquisto secondario funzionante.
[2025-04-22 ~17:25 CEST] - Sviluppo Frontend P2P: Aggiunta azione buyFromMarketplace ad authStore per chiamare API POST /api/marketplace/buy/:listingId.
[2025-04-22 ~17:25 CEST] - Sviluppo Frontend P2P: Modificato MarketplaceView.vue per usare la nuova azione buyFromMarketplace (passando listing_id) e gestirne la risposta.
[2025-04-22 ~17:25 CEST] - Debug Frontend P2P: Risolto errore 404 dovuto a errata costruzione URL API in auth.js (problema con template literal/caratteri).
[2025-04-22 ~17:25 CEST] - Test Frontend P2P: Eseguito test end-to-end con successo per acquisto P2P tramite UI Marketplace. Funzionalità confermata.
[2025-04-22 ~17:55 CEST] - Test Frontend P2P: Test per List/Cancel da UI MyTicketsView completati con successo.
[2025-04-22 ~17:55 CEST] - **[INIZIO FASE B] Integrazione Wallet Esterno:** Avviata implementazione per gestione azioni utente (Marketplace P2P, Acquisto Primario, Creazione Eventi) tramite wallet esterno (MetaMask) quando selezionato.
[2025-04-22 ~17:55 CEST] - Fase B.1 (Frontend P2P): Inizio modifiche a MyTicketsView.vue e MarketplaceView.vue per aggiungere logica condizionale (isUsingExternalWallet) e chiamate dirette a smart contract (approve, listItem, cancelListing, buyItem) tramite signer MetaMask.
[2025-04-22 ~18:00 CEST] - Fase B.1 (Frontend P2P): Tentativo di importare ABI/Indirizzi contratti in MyTicketsView.vue.
[Data Odierna - Es. 2025-04-22] - **[INIZIO FASE B] Integrazione Wallet Esterno**
    - Definito piano d'azione per implementare l'uso di wallet esterni (MetaMask) per firmare transazioni blockchain direttamente dal frontend quando l'utente ha selezionato `wallet_preference = 'external'`. [cite: 1]
    - Ambito confermato: Marketplace P2P (List, Cancel, Buy), Acquisto Primario (`buyAndMintTicket`), indirizzo Payout Creazione Evento (`registerEvent`). [cite: 1]
    - Deciso approccio incrementale:
        - Fase B.1: Frontend Marketplace P2P (List, Cancel, Buy). (IN CORSO)
        - Fase B.2: Frontend Acquisto Primario. (SUCCESSIVA)
        - Fase B.3: Backend Creazione Evento (Payout Address). (SUCCESSIVA)
    - Esaminato `stores/wallet.js`: Confermata presenza di stato `isUsingExternalWallet` e `signer`, funzione `ensureSigner`.
    - Definito approccio per gestione ABI/Indirizzi nel frontend: Copiare ABI JSON in `src/contracts/abi/`, definire indirizzi in `src/contracts/config.js`. [cite: 1]
    - **Avviata implementazione Fase B.1:** Iniziata modifica di `handleListTicket` in `MyTicketsView.vue` per aggiungere logica condizionale `if (walletStore.isUsingExternalWallet)` e import necessari per ABI/config. [cite: 1]
    - **Errore Bloccante (Risolto):** Riscontrato errore `[vite] Internal server error: Failed to resolve import "@/contracts/config.js"`. Causa identificata: il file `config.js` non era stato creato/posizionato correttamente in `src/contracts/`. L'utente ha confermato la creazione/correzione del file e l'errore è stato risolto. *(Nota: Questo documenta il ciclo di debug che abbiamo avuto, anche se causato da un mio fraintendimento precedente)* [cite: 1]
	[Data Odierna - Es. 2025-04-22] - Debug Frontend: Risolto errore Vite "Failed to resolve import '@/contracts/config.js'" assicurando la corretta posizione del file in 'src/contracts/config.js'.
[Data Odierna - Es. 2025-04-22] - Debug Frontend: Riscontrato nuovo problema: le pagine dell'applicazione appaiono vuote (renderizza solo layout base). Causa probabile: errore JavaScript runtime dopo modifiche a MyTicketsView.vue per importazione ABI/config e logica wallet esterno.
[Data Odierna - Es. 2025-04-22] - Debug Frontend: In corso analisi errori console browser per identificare la causa dell'errore runtime.
[Data Odierna] - Debug Frontend: Riscontrato errore Vue/JSReferenceError: useWalletStore is not definedinMyTicketsView.vuedurante l'esecuzione della funzionesetup. Causa: importazione diuseWalletStoremancante o errata.
[Data Odierna] - Debug Frontend: In corso verifica e correzione dell'istruzioneimport { useWalletStore } from '@/stores/wallet';inMyTicketsView.vue.
[Data Odierna] - Debug Frontend: Risolto errore JSReferenceError: TicketNFTJson is not defined(e simili) inMyTicketsView.vue. Causa identificata: incoerenza tra nome variabile usato nell'import (import TicketNFT_ABI from ...) e nome variabile usato per accedere alla proprietà.abi(const TICKET_NFT_ABI = TicketNFTJson.abi;). Corretto usando nomi coerenti per le variabili importate (TicketNFTJson,MarketplaceJson).
[Data Odierna] - Sviluppo Frontend P2P (Fase B.1): Il componenteMyTicketsView.vueora si carica correttamente dopo aver corretto gli errori di import/variabile. Contiene la logica condizionaleif (walletStore.isUsingExternalWallet)nella funzionehandleListTicketper la messa in vendita.
[Data Odierna] - Test Frontend P2P (Fase B.1): Avviata fase di test per la messa in vendita ("Vendi" inMyTicketsView.vue) utilizzando il **wallet esterno** (MetaMask).
[Data Odierna] - Debug Frontend P2P (Fase B.1): Riscontrato erroreTypeError: Cannot read from private fielddentroethers.jsquandoensureSignerinwallet.jschiamaprovider.getSigner(). Causa probabile: stato inconsistente provider/signer dopo interazioni wallet.
[Data Odierna] - Debug Frontend P2P (Fase B.1): Modificata funzioneensureSignerinwallet.js(versione DEBUG v2) per creare *sempre* un nuovoethers.BrowserProvidere ottenere il signer da esso, invece di riutilizzare istanze salvate nello stato. Aggiunto logging dettagliato.
[Data Odierna] - Test Frontend P2P (Fase B.1): In corso nuovo test messa in vendita ("Vendi") con wallet esterno usandoensureSignersemplificata.
[Data Odierna] - Debug Frontend P2P (Fase B.1): Riscontrato erroreTypeError: Cannot access private methoddentroethers.jsquando si tenta di chiamarenftContract.approve()daMyTicketsView.vueusando il signer esterno. Causa probabile: stato interno invalido dell'oggetto signer/provider restituito.
[Data Odierna] - Debug Frontend P2P (Fase B.1): Aggiunto logging dettagliato inhandleListTicketper ispezionare oggettosigner, istanzeethers.Contracte aggiunta chiamata read-only (ownerOf) preliminare per isolare il punto di fallimento.
[Data Odierna] - Debug Frontend P2P (Fase B.1): Riscontrato erroreTypeError: Cannot access private methoddentroethers.jsdurante chiamatanftContract.approve()oownerOf()daMyTicketsView.vue.
[Data Odierna] - Debug Frontend P2P (Fase B.1): Ripristinato testo mancante inwindow.promptdentrohandleListTicket.
[Data Odierna] - Debug Frontend P2P (Fase B.1): ModificataensureSignerinwallet.js(DEBUG v3) per salvareprovidernello store prima di chiamaregetSigner, nel tentativo di risolvere problemi di stato interno di ethers.js.
[Data Odierna] - Test Frontend P2P (Fase B.1): In corso nuovo test messa in vendita ("Vendi") con wallet esterno usandoensureSignerraffinata.
[Data Odierna - Es. 2025-04-22] - **Debug Frontend P2P (Fase B.1 - Tentativo #N):**
    - Riscontrato errore persistente `TypeError: Cannot access private method` originato da `ethers.js` durante chiamate a contratto (`approve`, `listItem`, `ownerOf`) da `MyTicketsView.vue` con wallet esterno[cite: 410, 412].
    - Le versioni precedenti di `ensureSigner` (DEBUG v2, v3) che forzavano ricreazione/salvataggio stato non hanno risolto[cite: 408, 414].
    - **Azione Corrente:** Modificata strategia:
        - Semplificata funzione `ensureSigner` in `stores/wallet.js` per ottenere un signer fresco senza logica di debug complessa.
        - Modificato `handleListTicket` in `MyTicketsView.vue` per istanziare `ethers.Contract` localmente *subito prima* delle chiamate `approve` e `listItem`, utilizzando il signer appena ottenuto.
        - Verificata nuovamente la correttezza degli ABI e degli indirizzi dei contratti nel frontend (`src/contracts/`).
    - **Stato:** In corso nuovo test del flusso di messa in vendita ("Vendi") con wallet esterno per validare questo approccio.


[Data Odierna - Es. 2025-04-22] - **Debug Frontend P2P (Fase B.1 - Successo Parziale):**
    - Riscontrato errore `-32000: transaction underpriced: gas tip cap 0` da Brave Wallet durante `signer.sendTransaction`, anche specificando parametri EIP-1559 (`maxFeePerGas`, `maxPriorityFeePerGas`).
    - Identificato problema probabile in Brave Wallet che ignora/sovrascrive i parametri EIP-1559 su Amoy.
    - **SOLUZIONE/WORKAROUND:** Modificato `handleListTicket` (`MyTicketsView.vue`) per usare il parametro **legacy `gasPrice`** (calcolato da `provider.getFeeData()`) invece di EIP-1559 nell'oggetto transazione passato a `signer.sendTransaction`.
    - **SUCCESSO:** Le transazioni `approve` e `listItem` per la messa in vendita con wallet esterno (Brave Wallet) sono state inviate e confermate con successo sulla rete Amoy usando il workaround `gasPrice`.
    - **Fase B.1 (Messa in vendita) completata.**
[Data Odierna - Es. 2025-04-22] - **Debug Esterno - Transfer & Listing:**
    - Tentativo di trasferimento manuale NFT (ID 9) da wallet interno a esterno (`0x356...`) tramite script backend (`transfer-nft.js`).
    - Risolto errore `MODULE_NOT_FOUND` nello script (percorso file).
    - Riscontrato errore DB `Chiave privata criptata non trovata per l'utente 1` nello script. Identificato ID utente corretto (5) come proprietario interno.
    - Risolto errore `ReferenceError: ethers is not defined` nello script aggiungendo `require('ethers')`.
    - **SUCCESSO:** Script `transfer-nft.js` eseguito con successo, trasferito Token ID 9 da wallet interno (`0x243...`) a wallet esterno (`0x356...`) su Amoy. Aggiornato DB manualmente. [cite: 1]
    - **Test Vendita Esterna (Token 9):** Tentativo di listare Token 9 da `MyTicketsView.vue` con wallet esterno (Brave Wallet).
    - Riscontrato errore `-32000: transaction underpriced: gas tip cap 0` in Brave Wallet, anche specificando parametri EIP-1559 (`maxFeePerGas`, `maxPriorityFeePerGas`) via `ethers.js`. [cite: 1]
    - **WORKAROUND:** Modificato `handleListTicket` per usare parametro **legacy `gasPrice`** (ottenuto da `provider.getFeeData()`).
    - **SUCCESSO:** Transazioni `approve` e `listItem` per Token ID 9 **completate con successo** via Brave Wallet usando `gasPrice` legacy. [cite: 1]
    - **Debug Acquisto Esterno:** Riscontrato `ReferenceError: walletStore is not defined` in `MarketplaceView.vue` al tentativo di acquisto.
    - **Fix:** Aggiunta inizializzazione `const walletStore = useWalletStore();` e import/definizioni mancanti (`MarketplaceJson`, `MARKETPLACE_ADDRESS`, `MARKETPLACE_ABI`) in `<script setup>` di `MarketplaceView.vue`. [cite: 1]
    - **Problema Aperto:** Il Token ID 9 listato non appare nel Marketplace (`WorkspaceListings` ritorna 0). Da investigare (probabile notifica mancante al backend dopo listing esterno). [cite: 1]
	[Data Odierna - Es. 2025-04-22] - **Debug & Successo Acquisto Esterno (Fase B.1):**
    - Risolto `ReferenceError: walletStore is not defined` in `MarketplaceView.vue` aggiungendo inizializzazione store e import/definizioni mancanti (ABI/Indirizzo Marketplace).
    - Testato acquisto P2P (Token 6) con wallet esterno (Brave Wallet) usando logica `handleBuy` aggiornata con `gasPrice` legacy ma senza invio commissione: fallito con `transaction execution reverted`.
    - **Identificata Causa Revert:** Mancato invio del valore necessario per coprire `listingPrice + commissione` come richiesto dalla funzione `buyItem` del contratto Marketplace.
    - **Fix:** Modificato `handleBuy` per leggere `serviceFeeBasisPoints` dal contratto Marketplace, calcolare `commissionAmount`, calcolare `totalValueToSend = listingPriceBigInt + commissionAmount`, e inviare `totalValueToSend` nel campo `value` della transazione `buyItem` (sempre usando `gasPrice` legacy).
    - **SUCCESSO:** Transazione `buyItem` per Token ID 6 **completata con successo** via Brave Wallet. Flusso di acquisto P2P con wallet esterno funzionante.
    - **Fase B.1 (Acquisto) completata.**
    - **Problema Aperto:** Listing creato con wallet esterno (Token 9) non visualizzato nel marketplace. Da investigare (probabile notifica/salvataggio mancante nel DB backend).
	[Data Odierna - Es. 2025-04-22] - **Implementazione Notifica Backend per Listing Esterno:**
    - Obiettivo: Risolvere il problema dei listing/acquisti fatti con wallet esterno che non aggiornavano lo stato nel database del backend (cache).
    - **Backend Service (`marketplaceService.js`):**
        - Aggiunta nuova funzione `processExternalListingNotification` (stile `const = async...`).
        - La funzione riceve i dati del listing dal controller.
        - Recupera `eventId` e `originalPrice` tramite query SQL diretta alla tabella `tickets` (sostituendo la dipendenza da `ticketService`).
        - Esegue un `INSERT ... ON CONFLICT ... DO UPDATE` (UPSERT) sulla tabella `listings` per creare/aggiornare il record del listing esterno (impostando `seller_user_id = NULL`).
        - Esegue un `UPDATE` sulla tabella `tickets` per impostare `is_listed = true`.
        - Gestisce correttamente la connessione al DB (`pool.connect`, `client.query`, `client.release`).
        - Esportata correttamente tramite `module.exports`.
    - **Backend Controller (`marketplaceController.js`):**
        - Rimossa vecchia definizione (stile `exports.`) se presente.
        - Aggiunta nuova funzione `handleExternalListingNotification` (stile `const = async...`).
        - La funzione riceve `notificationData` da `req.body`, esegue validazione base.
        - Chiama `marketplaceService.processExternalListingNotification`.
        - Gestisce risposta (201) o errore (`next(error)`).
        - Esportata correttamente tramite `module.exports`.
    - **Backend Router (`marketplaceRoutes.js`):**
        - Corretto import del controller per usare l'oggetto (`const marketplaceController = require(...)`).
        - Corretto uso del middleware di autenticazione (`protect` invece di `authMiddleware`).
        - Corretto riferimento alla funzione del controller (`marketplaceController.handleExternalListingNotification`).
        - Definita rotta `POST /api/marketplace/notify-external-listing` protetta da `protect`.
    - **Stato:** Backend modificato e riavviato con successo. Pronto per ricevere notifiche dal frontend.
	[Data Odierna - Es. 2025-04-22] - **Debug & Fix Interazione Wallet Esterno (Fase B.1):**
    - Risolto errore frontend `TypeError: Cannot read properties of undefined (reading 'post')` in `MyTicketsView.vue` (causato da ipotesi errata su `authStore.axiosInstance`). Corretto usando `axios.post` importato direttamente, come identificato dall'utente.
    - **Test Listing Esterno (NFT Trasferito):** Tentativo di listare NFT (es. ID 5) precedentemente trasferito a wallet esterno (`0x356...`) usando `handleListTicket` con workaround `gasPrice` legacy.
    - **SUCCESSO PARZIALE:** Transazione `approve` completata con successo on-chain.
    - **ERRORE BLOCCANTE:** Transazione `listItem` successiva **fallisce on-chain** con `transaction execution reverted (status: 0)`.
    - **Diagnosi Corrente:** Il problema risiede nella logica interna della funzione `listItem` nel contratto `Marketplace.sol`. Cause possibili: controllo "già listato", fallimento verifica approvazione interna, altre `require`.
    - **Azione:** In attesa di analisi codice `Marketplace.sol::listItem` o verifica stato on-chain (listing/approval) per determinare causa revert.
    - **Problema Notifica Backend:** Implementazione API backend `/notify-external-listing` e modifica frontend per chiamarla sono **in sospeso** finché il revert di `listItem` non è risolto.
	[2025-04-24 ~13:00 CEST] - Debug listItem Revert: Identificato indirizzo deployer (`0x356...`) tramite block explorer (transazione creazione TicketNFT).
[2025-04-24 ~13:05 CEST] - Debug listItem Revert: Tentativo fallito di verifica `TicketNFT` via Polygonscan UI ("Standard-Json-Input") a causa dell'impossibilità di inserire argomenti costruttore nel campo "ABI Data" non modificabile.
[2025-04-24 ~13:10 CEST] - Verifica Contratto: Installato e configurato plugin `@nomicfoundation/hardhat-verify`. Risolto errore API Key spostando file `.env` nella root del progetto come richiesto da `hardhat.config.js`.
[2025-04-24 ~13:12 CEST] - Verifica Contratto: Contratto `TicketNFT.sol` (0x64af...) verificato con successo su Amoy tramite `npx hardhat verify`.
[2025-04-24 ~13:14 CEST] - Verifica Contratto: Contratto `Marketplace.sol` (0xDE1A...) verificato con successo su Amoy tramite `npx hardhat verify`.
[2025-04-24 ~13:16 CEST] - Debug listItem Revert: Riscontrato ritardo/mancato aggiornamento UI Polygonscan che non mostra i contratti come verificati. Deciso di procedere ai controlli on-chain tramite console Hardhat.
[2025-04-24 ~13:18 CEST] - Debug listItem Revert: Eseguito test listing Token ID 5 (erroneamente, via pulsante test) da frontend. Log console confermano `approve` successo (con `wait(1)`) ma `listItem` ancora fallisce (reverted).
[2025-04-24 ~13:20 CEST] - Debug listItem Revert: Analizzato codice `handleListTicket`; confermato che l'attesa `await approveTx.wait(1)` è implementata correttamente. Ipotesi spostata su violazione Price Cap o ritardo propagazione stato/RPC.
[2025-04-24 ~13:25 CEST] - Debug listItem Revert: Chiarito uso pulsante test necessario a causa del mancato caricamento di NFT esterni nella lista UI standard (problema noto [cite: 289, 299, 308, 314]). Modificato pulsante test per usare Token ID 3.
[2025-04-24 ~13:31 CEST] - Debug listItem Revert: Piano d'azione definito: verificare `originalPrice` e `getApproved` per Token ID 3 via console Hardhat, aggiungere delay 2s nel frontend prima di `listItem`, ritestare listing Token ID 3.
[2025-04-24 ~13:36 CEST] - Debug listItem Revert: Eseguiti controlli on-chain via Hardhat console per Token ID 3. Risultati: `originalPrice` = 1e16 Wei (Price Cap OK), `getApproved` = Indirizzo Zero (confermando problema visibilità/persistenza approvazione).
[2025-04-24 ~13:40 CEST] - Fix listItem Revert: Aggiunto delay artificiale di 2s (`setTimeout`) in `MyTicketsView.vue` dopo `approveTx.wait(1)` e prima di `marketContract.listItem`.
[2025-04-24 ~13:43 CEST] - SUCCESSO Listing Esterno: Ritestato listing Token ID 3 da frontend con delay. Transazioni `approve` e `listItem` CONFERMATE con successo on-chain. Il delay ha risolto il revert.
[2025-04-24 ~13:43 CEST] - Errore Notifica Backend: Riscontrato errore 404 Not Found sulla chiamata `axios.post('/api/marketplace/notify-external-listing')` successiva al listing on-chain. Causa: chiamata API punta a server frontend invece che backend.
[2025-04-24 ~13:45 CEST] - Fix Notifica Backend: In corso modifica `axios.post` in `MyTicketsView.vue` per usare URL backend completo (`http://localhost:3000/api/...`).
[2025-04-24 ~13:45 CEST] - Fix Notifica Backend: Identificata causa errore 404 (URL relativo in chiamata Axios). Corretto `axios.post` in `MyTicketsView.vue` per usare URL backend completo (`http://localhost:3000/api/...`).
[2025-04-24 ~13:50 CEST] - Prossimo Passo (Fase B.1): Definiti i prossimi passi: implementazione completa `handleCancelListing` per wallet esterno (con relativa API backend) e risoluzione problema visibilità UI per dati wallet esterno.
[2025-04-24 ~14:00 CEST] - Sviluppo Visibilità UI: Iniziata implementazione per mostrare dati wallet esterno. Verificato schema DB `users`: confermata assenza colonna `external_wallet_address`. Adattato piano d'azione.
[2025-04-24 ~14:20 CEST] - Sviluppo Visibilità UI: Modificato controller backend `ticketController.js` (funzione `getMyTickets`) per accettare parametro query `?wallet_address=0x...`. Se presente, usa questo indirizzo per chiamare `ticketService.findTicketsByOwner`; altrimenti usa `req.user.walletAddress` (wallet interno).
[2025-04-24 ~14:20 CEST] - Sviluppo Visibilità UI: Modificato controller backend `ticketController.js` (funzione `getMyTickets`) per accettare parametro query `?wallet_address=0x...`. Se presente, usa questo indirizzo per chiamare `ticketService.findTicketsByOwner`; altrimenti usa `req.user.walletAddress` (wallet interno).
[2025-04-24 ~14:25 CEST] - Sviluppo Visibilità UI: Inizio modifiche frontend. Obiettivo: modificare azione store Pinia (`fetchMyTickets`) per inviare `wallet_address` alla API backend quando si usa wallet esterno. In attesa del codice attuale dell'azione.
[2025-04-24 ~14:25 CEST] - Sviluppo Visibilità UI: Inizio modifiche frontend...
[2025-04-24 ~14:30 CEST] - Sviluppo Visibilità UI: Modificata azione `fetchMyTickets` nello store Pinia (`stores/auth.js`?) per costruire dinamicamente l'URL API (`/api/tickets/my` vs `/api/tickets/my?wallet_address=...`) in base a `walletStore.isUsingExternalWallet`.
[2025-04-24 ~14:35 CEST] - Fix Frontend fetchMyTickets: Rifattorizzata logica dell'azione Pinia `fetchMyTickets` (stores/auth.js) per gestire correttamente il caso in cui la preferenza è 'external' ma l'indirizzo del wallet (`walletStore.account`) non è ancora disponibile. Aggiunto flag `canFetch` e migliorata gestione header Axios. Risolve il problema "Cannot determine wallet context" che impediva il caricamento dei biglietti.
[2025-04-24 ~14:45 CEST] - Debug Frontend fetchMyTickets: Confermato che la nuova logica in `fetchMyTickets` (stores/auth.js) funziona correttamente, ma evidenzia un problema di timing. La funzione viene chiamata prima che l'indirizzo del wallet esterno (`walletStore.account`) sia disponibile dopo la connessione. Diagnosi: necessario rendere il fetch reattivo allo stato del wallet nel componente chiamante (`MyTicketsView.vue`).
[2025-04-24 ~14:55 CEST] - Fix Frontend MyTicketsView: Implementato `watchEffect` nel componente `MyTicketsView.vue` per rendere il caricamento dei biglietti reattivo allo stato di login (`authStore.isAuthenticated`) e allo stato del wallet esterno (`walletStore.isUsingExternalWallet`, `walletStore.account`). Rimosso caricamento diretto da `onMounted`. Questo risolve il problema del mancato caricamento dei biglietti con wallet esterno quando l'indirizzo non è immediatamente disponibile al mount.
[2025-04-24 ~14:50 CEST] - Debug Frontend MyTicketsView: Identificato che `fetchMyTickets` ora carica correttamente i dati per il wallet interno, ma la pagina rimane bianca. Il problema è probabilmente un errore JavaScript nel rendering del template (`<template>`) del componente dopo che i dati sono disponibili. Inizio debug del template.
[2025-04-24 ~15:00 CEST] - Successo Rendering Interno: Confermato che `MyTicketsView.vue` (con `watchEffect` corretto e template originale) ora visualizza correttamente i biglietti per gli utenti con wallet interno. Il problema della pagina bianca era legato a modifiche precedenti nel template/formattatori.
[2025-04-24 ~15:15 CEST] - Fix Frontend MyTicketsView: Modificato `watchEffect` per svuotare esplicitamente `authStore.myTickets` quando la preferenza è esterna ma l'indirizzo (`walletStore.account`) non è disponibile. Questo previene la visualizzazione di dati interni obsoleti durante la navigazione. Identificato che il prossimo passo richiede la verifica dell'aggiornamento reattivo di `walletStore.account` alla connessione del wallet.
[2025-04-24 ~15:30 CEST] - Fix Frontend MyTicketsView: Corretto `watchEffect` per osservare `walletStore.connectedAddress` invece di `walletStore.account` (che non esisteva). Questo permette al watcher di riattivarsi correttamente dopo l'aggiornamento dell'indirizzo nello store `wallet.js` seguito alla connessione del wallet esterno.
[2025-04-24 ~15:45 CEST] - Fix Cross-Store State Timing: Modificata azione `fetchMyTickets` (auth.js) per accettare un indirizzo esterno opzionale come parametro. Modificato `watchEffect` (MyTicketsView.vue) per passare l'indirizzo esterno rilevato all'azione `fetchMyTickets`. Questo risolve il problema di timing per cui `fetchMyTickets` leggeva lo stato obsoleto di `walletStore` subito dopo la riattivazione del watcher.
[2025-04-24 ~15:55 CEST] - Debug External Wallet Flow: Analizzati log che mostrano: 1) Chiamata API per wallet esterno ha successo ma restituisce 0 biglietti. 2) Evento `accountsChanged[]` imprevisto causa reset dello stato wallet. 3) `resetState` in `wallet.js` impostava erroneamente `isUsingExternalWallet=false`.
[2025-04-24 ~15:55 CEST] - Fix Wallet Store: Modificata funzione `resetState` in `wallet.js` per non alterare `isUsingExternalWallet`, ma solo resettare stato connessione (`connectedAddress`, `signer`, etc.).
[2025-04-24 ~16:05 CEST] - Debug Backend API: Identificato che l'API `GET /api/tickets/my?wallet_address=...` restituisce 0 biglietti anche se il DB contiene dati per l'indirizzo specificato. Il problema è localizzato nella logica backend (controller/service/query SQL).
[2025-04-24 ~16:28 CEST] - SUCCESSO: Confermata la corretta visualizzazione dei biglietti per il wallet esterno dopo aver corretto la query backend (case-insensitive) e la logica di passaggio parametri nel frontend (`watchEffect` -> `WorkspaceMyTickets`). Flusso di visualizzazione biglietti funzionante per entrambi i contesti (interno/esterno).
[2025-04-24 ~15:50 CEST] - Debug UI Reactivity: Riscontrato che la UI non si aggiorna immediatamente dopo lo switch da wallet esterno a interno in `SettingsView.vue`, richiedendo un refresh manuale. Causa probabile: il pulsante "Usa Wallet Interno" chiama ancora `disconnectWallet` invece della nuova azione `switchToInternalMode` che aggiorna correttamente lo stato `isUsingExternalWallet`.
[2025-04-24 ~16:00 CEST] - Fix Frontend SettingsView: Modificata funzione `switchToInternal` per chiamare la corretta azione `walletStore.switchToInternalMode()` invece di `disconnectWallet`. Questo assicura che lo stato reattivo `isUsingExternalWallet` venga impostato a `false` e la UI si aggiorni immediatamente durante lo switch da modalità esterna a interna.
[2025-04-24 ~15:59 CEST] - RISOLTO: Confermata la corretta visualizzazione dei biglietti e l'aggiornamento UI istantaneo per entrambi i contesti wallet (interno/esterno) e durante lo switch di modalità, a seguito delle correzioni applicate a `MyTicketsView.vue`, `SettingsView.vue`, `auth.js` (store), `wallet.js` (store) e `ticketService.js` (backend).